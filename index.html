<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>PromptForge RIS v1.2.1 (Single-file)</title>
  <style>

    :root{
      color-scheme: light;
      --bg:#FFFFFF; --card:#ffffff; --text:#444444; --muted:#6b7280;
      --border:#e3e6ea; --border2:#d5d9df; --accent:#ea4c89; --onAccent:#FFFFFF;
      --panel:#f2f4f7; --panel2:#fbfbfc; --ghost:#f7f7f7;
      --ok:#067647; --err:#b42318;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --radius:16px; --shadow: 0 1px 0 rgba(16,24,40,.02), 0 8px 24px rgba(16,24,40,.06);
      --tap:44px;
    }
    :root[data-theme="dark"]{
      color-scheme: dark;
      --bg:#000000; --card:#0b0b0b; --text:#ECECEC; --muted:#b7b7b7;
      --border:#2a2f3a; --border2:#3a4252; --accent:#f79aaf; --onAccent:#000000;
      --panel:#1b1f27; --panel2:#161a22; --ghost:#1a1e25;
      --ok:#34d399; --err:#fb7185;
    }

    *{box-sizing:border-box}
    body{ margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--text); -webkit-text-size-adjust:100%;}
    code{font-family:var(--mono); font-size:.95em}
    .app{
      max-width: 980px; margin:0 auto;
      padding: calc(env(safe-area-inset-top) + 10px) 12px calc(120px + env(safe-area-inset-bottom));
    }

    header{
      position: sticky; top:0; z-index:20;
      background: color-mix(in oklab, var(--bg) 88%, var(--panel2) 12%);
      backdrop-filter: blur(6px);
      border-bottom: 1px solid var(--border);
      padding: 14px 16px;
      margin: -10px -12px 12px;
      display:flex; justify-content:center; align-items:center;
    }
    .headrow{display:flex; align-items:center; justify-content:center; width:100%;}
    .titlewrap{ text-align:center; max-width: min(92vw, 720px); }
    h1{ font-size: 18px; margin:0; line-height:1.15; letter-spacing:.2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .subtitle{ margin:4px 0 0; font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}

    /* Toasts */
    .toastHost{
      position: fixed; left:50%; top: 10px; transform: translateX(-50%);
      z-index: 1000; display:flex; flex-direction:column; gap:8px;
      padding-top: env(safe-area-inset-top);
      width: min(92vw, 620px);
      pointer-events:none;
    }
    .toast{
      pointer-events:none;
      border:1px solid var(--border2);
      background:var(--card);
      border-radius: 999px;
      box-shadow: var(--shadow);
      padding: 10px 14px;
      display:flex; align-items:center; gap:10px;
      font-size: 13px;
      line-height:1.25;
      opacity: 0;
      transform: translateY(-6px);
      transition: opacity .12s ease, transform .12s ease;
    }
    .toast.show{opacity:1; transform: translateY(0);}
    .dot{ width:10px; height:10px; border-radius:999px; background: var(--ok); flex:0 0 auto;}
    .toast.err .dot{ background: var(--err); }
    .toast .msg{flex:1; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
    .toast .tag{font-family:var(--mono); font-size:11px; color:var(--muted);}

    /* Drawer */
    .drawerBackdrop{ position: fixed; inset:0; background: rgba(0,0,0,.35); display:none; z-index:50; }
    .drawer{
      position: fixed; top:0; right:0; height:100%; width: min(92vw, 440px);
      background:var(--card); border-left:1px solid var(--border);
      box-shadow: -10px 0 40px rgba(0,0,0,.12);
      transform: translateX(110%); transition: transform .18s ease;
      z-index:60;
      padding: calc(env(safe-area-inset-top) + 12px) 12px calc(env(safe-area-inset-bottom) + 14px);
      display:flex; flex-direction:column; gap:10px;
      overflow:auto;
    }
    .drawer.open{ transform: translateX(0); }
    .drawerBackdrop.open{ display:block; }
    .drawer h2{margin:0; font-size:16px}
    .drawer .small{color:var(--muted); font-size:12px; line-height:1.35}
    .hr{height:1px; background:var(--border); margin:6px 0}
    .btnrow{display:flex; gap:8px; flex-wrap:wrap}
    .drawer details{ border:1px solid var(--border); border-radius: 12px; overflow:hidden; background:var(--card); }
    .drawer details > summary{ list-style:none; cursor:pointer; padding: 10px 10px; font-weight:900; background:var(--panel2); border-bottom:1px solid var(--border); }
    .drawer details > summary::-webkit-details-marker{display:none}
    .drawer details .dsec{ padding: 10px 10px; }

    /* Buttons */
    .btn{
      height: var(--tap);
      padding: 0 12px;
      border-radius: 12px;
      border:1px solid var(--border2);
      background:var(--card);
      cursor:pointer;
      font-weight:800;
    }
    .btn.primary{ background: var(--accent); border-color: var(--accent); color:var(--onAccent); }
    .btn.ghost{ background:var(--ghost); }
    .btn.danger{ border-color: color-mix(in oklab, var(--err) 35%, var(--border2)); background: color-mix(in oklab, var(--err) 10%, #fff); color: var(--err); }
    .btn.small{ height: 38px; border-radius: 10px; font-weight:800; }

    /* Cards */
    details.card{
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      margin: 12px 0;
    }
    details.card > summary{
      list-style:none;
      cursor:pointer;
      padding: 14px 14px;
      display:flex;
      align-items:center;
      gap:10px;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    details.card > summary::-webkit-details-marker{display:none}
    .sumLeft{font-weight:900}
    .sumRight{
      margin-left:auto;
      font-size:12px;
      color:var(--muted);
      font-weight:700;
      max-width: 62%;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      text-align:right;
    }
    .section{ padding: 0 14px 14px; }

    /* Form */
    .row{ display:grid; grid-template-columns: 1fr; gap:6px; margin: 10px 0; }
    label{ font-weight:900; font-size: 12px; color: var(--text); }
    select,input,textarea{
      width:100%;
      border: 1px solid var(--border2);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 14px;
      background:var(--card);
      outline:none;
      min-height: var(--tap);
    }
    textarea{ min-height: 96px; resize: vertical; font-family: var(--mono); font-size: 12px; line-height:1.35; }
    .help-inline{ margin-top:6px; font-size: 12px; color: var(--muted); line-height:1.35; }
    .opt-desc{ font-size:12px; color: var(--muted); margin-top: 6px; line-height:1.35; }
    .suggest{ font-size:12px; color: var(--text); background:var(--panel); border:1px dashed var(--border2); border-radius: 12px; padding: 10px 12px; line-height:1.35; margin-top:8px; }

    /* Output */
    .codewrap{ border-radius: 14px; overflow:hidden; border:1px solid #111; background:#0b0b0b; }
    pre{ margin:0; padding: 12px; overflow:auto; max-height: 56vh; color:#eaeaea; font-family: var(--mono); font-size: 12px; line-height:1.35; white-space: pre; }
    .outActions{ display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; align-items:center; }
    .mini{ font-size:12px; color:var(--muted); }

    
    .btn.tiny{ height: 34px; padding: 0 10px; border-radius: 10px; font-size:12px; font-weight:900; }
    .btn.small{ height: 34px; padding: 0 10px; border-radius: 10px; }
    .iconBtn{ position:absolute; right:16px; top:14px; }

    .list{ display:flex; flex-direction:column; gap:8px; }
    .listitem{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding: 10px 12px;
      border:1px solid var(--border2);
      border-radius: 14px;
      background: var(--card);
    }
    .liLeft{ min-width:0; flex:1; }
    .liTitle{ font-weight:1000; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .liMeta{ font-size:11px; color:var(--muted); margin-top:2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .liRight{ display:flex; gap:6px; flex-wrap:wrap; justify-content:flex-end; }

/* Toggle */
    .toggleRow{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding: 10px 12px; border: 1px solid var(--border2); border-radius: 12px; background:var(--card);
    }
    .toggleRow b{font-size:13px}
    .switch{
      width: 54px; height: 32px;
      border-radius: 999px;
      border: 1px solid var(--border2);
      background:var(--panel);
      position: relative;
      cursor:pointer;
      flex: 0 0 auto;
    }
    .knob{
      position:absolute; top: 3px; left: 3px;
      width: 26px; height: 26px;
      border-radius: 999px;
      background:var(--card);
      border:1px solid var(--border2);
      transition: transform .15s ease, background .15s ease;
    }
    .switch.on{ background: #111; border-color:#111; }
    .switch.on .knob{ transform: translateX(22px); border-color:#111; }

    /* Category groups */
    details.group{
      border: 1px solid var(--border);
      border-radius: 14px;
      overflow:hidden;
      margin: 10px 0;
      background:var(--card);
    }
    details.group > summary{
      list-style:none;
      cursor:pointer;
      padding: 12px 12px;
      display:flex; align-items:center; gap:10px;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      background:var(--panel2);
      border-bottom: 1px solid var(--border);
    }
    details.group > summary::-webkit-details-marker{display:none}
    .groupTitle{font-weight:900}
    .groupMeta{margin-left:auto; font-size:12px; color:var(--muted); font-weight:800}

    /* Field rows + per-field details */
    .fieldRow{
      border:1px solid var(--border);
      border-radius: 14px;
      padding: 10px 10px;
      margin: 10px 0;
      background:var(--card);
    }
    .fieldTop{ display:flex; align-items:center; gap:10px; }
    .fieldTop .lab{ font-weight:900; font-size:12px; color:#222; flex:1; min-width:0; }
    .fieldTop .path{ font-family: var(--mono); font-size:11px; color: var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width: 45%; text-align:right;}
    .fieldMoreBtn{ height: 34px; padding: 0 10px; border-radius: 10px; border:1px solid var(--border2); background:var(--card); font-weight:900; cursor:pointer; }

    .fieldMore{ margin-top:10px; display:none; }
    .fieldMore.open{ display:block; }

    /* Value info box (More) */
    .valueInfoBox{
      border: 1px solid var(--border2);
      border-radius: 14px;
      background:var(--card);
      padding: 10px 12px;
      margin-top:10px;
    }
    .valueInfoBox .hdr{ display:flex; gap:10px; align-items:center; }
    .valueInfoBox .hdr b{ font-size:12px; }
    .valueInfoBox .hdr .chip{
      font-family: var(--mono);
      font-size:11px;
      color:#111;
      background:var(--panel);
      border:1px solid var(--border2);
      border-radius:999px;
      padding: 4px 8px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 60%;
    }
    .valueInfoBox .body{
      margin-top:8px;
      font-size:12px;
      color:var(--muted);
      line-height:1.35;
    }
    .valueInfoBox .body .k{ color:#111; font-weight:900; margin-top:10px; }
    .valueInfoBox ul{ margin:6px 0 0 18px; padding:0; }

    /* Sticky bottom navbar */
    .actionbar{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 10px;
      width: min(980px, calc(100vw - 24px));
      background:var(--card);
      border: 1px solid var(--border);
      border-radius: 999px;
      box-shadow: var(--shadow);
      padding: 8px 8px calc(12px + env(safe-area-inset-bottom));
      display:flex;
      gap:8px;
      z-index: 40;
      align-items:center;
    }
    .actionbar .pill{
      flex: 1;
      height: 44px;
      border-radius: 999px;
      border: 1px solid var(--border2);
      background:var(--card);
      font-weight:900;
      cursor:pointer;
    }
    .actionbar .pill.primary{ background:var(--accent); border-color:var(--accent); color:var(--onAccent); }
    .actionbar .pill.small{ flex: 0 0 auto; width: 118px; }

    @media (min-width: 860px){
      .row.grid2{ grid-template-columns: 280px 1fr; align-items:center; }
      h1{font-size:20px}
      pre{max-height: 62vh}
      .actionbar{ padding: 10px 10px calc(14px + env(safe-area-inset-bottom)); }
      .toastHost{ width: min(92vw, 720px); }
    }
  </style>
</head>

<body>
  <div class="toastHost" id="toastHost" aria-live="polite"></div>

  <header>
    <div class="headrow">
      <button class="btn small iconBtn" id="hamburgerBtn" title="Menu" aria-label="Menu">☰</button>
      <div class="titlewrap">
        <h1 id="appTitle"></h1>
        <div class="subtitle">PromptForge, Regenerative Image System • Brave/Firefox compatible</div>
      </div>
      <span id="diagBadgeHost" class="pill small" style="display:none;margin-right:8px;align-items:center;gap:6px"></span>
      <button class="btn small iconBtn" id="themeToggleBtn" title="Toggle theme">☀</button>
    </div>
  </header>

  <div class="drawerBackdrop" id="drawerBackdrop"></div>
  <aside class="drawer" id="drawer">
    <div style="display:flex;align-items:center;gap:10px">
      <h2 style="flex:1">Actions</h2>
      <button class="btn small" id="closeDrawer">Close</button>
    </div>

    <div class="small">
      Bundles include state + user presets. JSON import/export is for generated output.
    </div>

    <details open id="drawerChangelog">
      <summary>Changelog</summary>
      <div class="dsec" id="changelogBody"></div>
    </details>

    <details id="drawerFiles">
      <summary>Files</summary>
      <div class="dsec">
        <div class="btnrow">
          <button class="btn" id="importBundleBtn">Import Bundle</button>
          <button class="btn" id="exportBundleBtn">Export Bundle</button>
          <button class="btn" id="exportJSONBtn">Export JSON</button>
          <button class="btn" id="importJSONBtn">Import JSON</button>
        </div>
      </div>
    </details>

    <details id="drawerSchema">
      <summary>Schema</summary>
      <div class="dsec">
        <div class="btnrow">
          <button class="btn" id="copySchemaBtn">Copy JSON Schema</button>
          <button class="btn" id="saveSchemaBtn">Save JSON Schema</button>
          <button class="btn" id="validateNowBtn">Validate Now</button>
        </div>
        <div class="help-inline">Schema ID: <code id="schemaIdLabel"></code></div>
      </div>
    </details>

    <details id="drawerAppearance">
      <summary>Appearance</summary>
      <div class="dsec">
        <div class="row grid2">
          <label>Theme</label>
          <select id="themeSelect">
            <option value="auto">Auto (system)</option>
            <option value="light">Light</option>
            <option value="dark">Dark</option>
          </select>
        </div>
        <div class="help-inline">Auto follows OS preference. Stored locally and included in bundles.</div>
      </div>
    </details>

    <details id="drawerMacros">
      <summary>Macros</summary>
      <div class="dsec">
        <div class="small">Apply opinionated patches (safe defaults) to reduce artifacts and improve adherence.</div>
        <div class="btnrow" style="margin-top:8px">
          <button class="btn" id="macroNoTextBtn">No-text strict</button>
          <button class="btn" id="macroHandsBtn">Hands-safe</button>
          <button class="btn" id="macroSkinBtn">Skin realism</button>
          <button class="btn" id="macroIdentityBtn">Identity lock</button>
        </div>
      </div>
    </details>

    <details id="drawerSweep">
      <summary>Sweeps</summary>
      <div class="dsec">
        <div class="small">Generate multiple Prompt Packs by sweeping one field across values (A/B testing in ChatGPT).</div>
        <div class="row grid2" style="margin-top:8px">
          <label>Field path</label>
          <input id="sweepPath" placeholder="e.g., lighting.type" list="schemaPathList" />
        </div>
        <div class="row">
          <label>Values (comma or newline separated)</label>
          <textarea id="sweepValues" placeholder="studio softbox\nnatural daylight\ncinematic lighting"></textarea>
        </div>
        <div class="btnrow">
          <button class="btn" id="runSweepBtn">Generate sweep</button>
          <button class="btn danger" id="clearSweepBtn">Clear</button>
        </div>
        <div class="hr"></div>
        <div id="sweepResults" class="small"></div>
      </div>
    </details>

    <details id="drawerPresets">
      <summary>Presets</summary>
      <div class="dsec">
        <div class="btnrow">
          <button class="btn" id="savePresetBtn">Save Preset As…</button>
        </div>

        <div class="hr"></div>

        <div class="row">
          <input id="presetSearch" placeholder="Filter presets…" />
        </div>

        <div id="presetManager" class="list"></div>
        <div class="help-inline">Tip: loading a preset also resets the baseline (Reset Edits returns to the post-preset state).</div>
      </div>
</details>

<details id="drawerRuns">
  <summary>Runs</summary>
  <div class="dsec">
    <div class="btnrow">
      <button class="btn" id="exportRunsBtn">Export Runs</button>
      <button class="btn danger" id="clearRunsBtn">Clear Runs</button>
    </div>
    <div class="toggleRow" style="margin-top:10px">
      <div>
        <b>Auto-save on Generate</b>
        <div class="help-inline">Automatically saves a run snapshot each time you press Generate.</div>
      </div>
      <div class="switch" id="autoSaveSwitch" role="switch" aria-checked="false"><div class="knob"></div></div>
    </div>
    <div class="hr"></div>
    <div class="small" id="runsBody"></div>
  </div>
</details>

<details id="drawerResets">
      <summary>Resets</summary>
      <div class="dsec">
        <div class="btnrow">
          <button class="btn danger" id="resetAllBtn">Reset ALL to Defaults</button>
          <button class="btn danger" id="resetEditsBtn">Reset edits</button>
          <button class="btn danger" id="resetBaseBtn">Reset to template base</button>
        </div>
      </div>
    </details>

    <div class="hr"></div>

    <div class="small">
      Clipboard: fallback copy is enabled for offline Android local-file contexts.
    </div>

    <input id="fileInput" type="file" accept="application/json" style="display:none" />
  </aside>

  <main class="app">
<!-- STEP 1 -->
    <details class="card" id="card1" open>
      <summary>
        <span class="sumLeft">Step 1 — Preset Driven</span>
        <span class="sumRight" id="step1Hint">Template + preset</span>
      </summary>
      <div class="section">

        <div class="row grid2">
          <label>Template</label>
          <div>
            <select id="templateSelect"></select>
            <div class="help-inline" id="templateDesc"></div>
          </div>
        </div>

        <div class="row grid2">
          <label>Preset</label>
          <div>
            <select id="presetSelect"></select>
            <div class="help-inline">Built-ins apply stable defaults. User presets store only your overrides.</div>
          </div>
        </div>

        <div class="row">
          <div class="toggleRow">
            <div>
              <b>Include master_prompt</b>
              <div class="help-inline">ON: include <code>prompt_output.master_prompt</code>. OFF: omit it (cleaner JSON).</div>
            </div>
            <div class="switch" id="masterSwitch" role="switch" aria-checked="false"><div class="knob"></div></div>
          </div>
        </div>

        <div class="row grid2">
          <label>Output mode</label>
          <select id="outputMode">
  <option value="prompt_pack">Prompt Pack (ChatGPT Image)</option>
  <option value="prompt_pack_and_json">Prompt Pack + JSON</option>
  <option value="full_json">Full JSON</option>
  <option value="json_patch">JSON Patch (diff)</option>
  <option value="json_schema">JSON Schema (v1)</option>
  <option value="json_schema_and_json">JSON Schema + JSON</option>
  <option value="exec_json">Executable JSON (ChatGPT)</option>
  <option value="prompt_only">Master Prompt (legacy)</option>
  <option value="prompt_and_json">Master Prompt + JSON</option>
  <option value="debug">Debug</option>
</select>
        </div>
<div class="help-inline" id="status1"></div>
      </div>
    </details>

    <!-- STEP 2 -->
    <details class="card" id="card2">
      <summary>
        <span class="sumLeft">Step 2 — Common Fields</span>
        <span class="sumRight">Quick edits</span>
      </summary>
      <div class="section">
        <div class="help-inline">Quick edits. Categories accordion (one open at a time). Field “More” shows value-specific guidance.</div>

        <div class="row">
          <div class="toggleRow">
            <div>
              <b>Reference images included</b>
              <div class="help-inline">ON if you will upload one or more reference images in the ChatGPT chat alongside this prompt. Appends the line <code>Reference images included</code> to the Prompt Pack.</div>
            </div>
            <div class="switch" id="refSwitch" role="switch" aria-checked="false"><div class="knob"></div></div>
          </div>
        </div>

        <div class="row">
          <div class="toggleRow">
            <div>
              <b>Strict schema validation</b>
              <div class="help-inline">ON: validate types + known enums + required core fields before compile. Issues appear in Output lint panel.</div>
            </div>
            <div class="switch on" id="strictSwitch" role="switch" aria-checked="true"><div class="knob"></div></div>
          </div>
        </div>


        <div class="row">
          <div class="toggleRow">
            <div>
              <b>Lock run ID</b>
              <div class="help-inline">ON: pins <code>meta.run_id</code> for reproducibility. OFF: compiler auto-generates a fresh run ID per build.</div>
            </div>
            <div style="display:flex;align-items:center;gap:8px">
              <button class="btn tiny" id="newRunIdBtn" title="Generate a new run_id">New</button>
              <div class="switch" id="runIdLockSwitch" role="switch" aria-checked="false"><div class="knob"></div></div>
            </div>
          </div>
        </div>

<div class="row">
  <div class="toggleRow">
    <div>
      <b>Show only modified fields</b>
      <div class="help-inline">ON: show only fields that differ from the current template base.</div>
    </div>
    <div class="switch" id="diffSwitch" role="switch" aria-checked="false"><div class="knob"></div></div>
  </div>
</div>
        <div id="commonFields"></div>

        <div class="outActions">
          <button class="btn primary" id="unlockExpertBtn">Unlock Expert Mode</button>
        </div>

        <div class="help-inline" id="status2"></div>
      </div>
    </details>
<!-- STEP 4 -->
    <details class="card" id="card4" style="display:none">
      <summary>
        <span class="sumLeft">Step 4 — God Mode (Ultra Elite)</span>
        <span class="sumRight">Superset controls</span>
      </summary>
      <div class="section">
        <div class="help-inline">Ultra Elite deep controls.</div>
        <div id="godFields"></div>
        <div class="help-inline" id="status4"></div>
      </div>
    </details>

    <!-- Output -->
    <details class="card" id="cardOut">
      <summary>
        <span class="sumLeft">Output</span>
        <span class="sumRight" id="outHint">exec_json</span>
      </summary>
      <div class="section">
        <div id="lintBox" class="suggest" style="display:none"></div>
        <div class="codewrap">
          <pre><code id="outMain">{}</code></pre>
        </div>

        <div class="outActions">
  <button class="btn primary" id="copyPackBtn">Copy Prompt Pack</button>
  <button class="btn" id="copyJsonBtn">Copy JSON</button>
  <button class="btn" id="downloadPackBtn">Download .txt</button>
  <button class="btn" id="saveRunBtn">Save to History</button>
</div>
<div class="outActions">
          <button class="btn" id="expandBtn">Expand</button>
          <div style="flex:1"></div>
          <div class="mini">Save as JSON:</div>
          <div class="switch" id="saveSwitch" role="switch" aria-checked="false"><div class="knob"></div></div>
        </div>

        <div class="row grid2" style="margin-top:10px">
          <label>Chat Name</label>
          <input id="chatNameInput" placeholder="Used in Executable JSON header + JSON meta" />
        </div>

        <div class="row grid2">
          <label>Purpose</label>
          <input id="purposeInput" placeholder="Used in Executable JSON header + JSON meta" />
        </div>

        <div class="row grid2">
          <label>Filename</label>
          <input id="filenameInput" placeholder="Optional filename (without .json)" />
        </div>

        <div class="outActions">
          <button class="btn primary" id="saveFileBtn">Save File</button>
        </div>

        <div class="help-inline" id="statusOut"></div>
      </div>
    </details>

  </main>

  <!-- Sticky bottom navbar -->
  <div class="actionbar" role="toolbar" aria-label="Quick actions">
    <button class="pill primary" id="barGenerate">Generate</button>
    <button class="pill" id="barCopy" title="Copy prompt + JSON to clipboard">Copy</button>
    <button class="pill small" id="barImport" title="Import Template and/or Preset">Import</button>
    <button class="pill small" id="barApply" title="Apply selected template/preset + output settings">Apply Changes</button>
  </div>

  <datalist id="schemaPathList"></datalist>

  <script>
    /* =========================================================
      PromptForge RIS v1.2.1 (Single-file)
      USER_VISIBLE_CHANGES:
      - Step 0 “Merge & Seed”: Name + Purpose + Prompt + JSON merge + copy + upload
      - Step 0: Inject toggle + Detect template toggle
      - Executable JSON header now includes Name + Purpose
      - Dropdown option descriptors (e.g., 4:5 — Instagram)
      - Field “More” shows selected-value description/recommendations/most common/reasoning

      NON_USER_VISIBLE_CHANGES:
      - Centralized value-info metadata model for enum options
      - Template detection heuristic for Step 0 JSON ingest
      - Internal meta standardization: meta.app_name + schema_version
    ========================================================= */

    const APP_NAME = "PromptForge RIS";
    const APP_VERSION = "v1.2.1-singlefile";

    const LS_KEY = "promptforge_ris_user_presets_v110";
    const LS_STATE = "promptforge_ris_state_v110";
    const LS_RUNS = "promptforge_ris_runs_v110";
    const LS_LAST_SEEN = "promptforge_ris_last_seen_version";
const LS_THEME = "promptforge_ris_theme_mode_v110";

    // Global UI state (declared early to avoid TDZ during template initialization)
    let themeMode = "auto";
    let lockRunId = false;

/* ---------- Theme (Light/Dark/Auto) ---------- */
const MQL_DARK = window.matchMedia ? window.matchMedia("(prefers-color-scheme: dark)") : null;

function normalizeThemeMode(v){
  const x = String(v || "").toLowerCase().trim();
  return (x === "dark" || x === "light" || x === "auto") ? x : "auto";
}

function getEffectiveTheme(mode){
  const m = normalizeThemeMode(mode);
  if (m === "auto"){
    const prefersDark = !!(MQL_DARK && MQL_DARK.matches);
    return prefersDark ? "dark" : "light";
  }
  return m;
}

function applyTheme(mode, {persist=true, quiet=false}={}){
  themeMode = normalizeThemeMode(mode);
  const effective = getEffectiveTheme(themeMode);
  document.documentElement.dataset.theme = effective;
  document.documentElement.style.colorScheme = effective;

  // UI sync (safe if elements not yet present)
  if ($("themeSelect")) $("themeSelect").value = themeMode;
  if ($("themeToggleBtn")) $("themeToggleBtn").textContent = (effective === "dark") ? "☾" : "☀";
  if ($("barTheme")) $("barTheme").textContent = (effective === "dark") ? "☾" : "☀";

  if (persist){
    try{ localStorage.setItem(LS_THEME, themeMode); }catch(_){}
    try{ if (typeof saveState === "function") saveState(); }catch(e){ __PF_DIAG.add("theme/saveState", e); }
  }
  if (!quiet) toast(`Theme: ${themeMode} (${effective})`, "ok", "Appearance");
}

if (MQL_DARK && MQL_DARK.addEventListener){
  MQL_DARK.addEventListener("change", ()=>{
    if (normalizeThemeMode(themeMode) === "auto"){
      applyTheme("auto", {persist:false, quiet:true});

      if ($("appTitle")) $("appTitle").textContent = `${APP_NAME} ${APP_VERSION} (Offline)`;
    }
  });
}


    const SCHEMA_ID_V1 = "promptforge.ris.personshot@1.0.0";
    const SCHEMA_DRAFT = "https://json-schema.org/draft/2020-12/schema";

    /* ---------- DOM helpers ---------- */
    const __NULL_EL = new Proxy({},{
  get(_t,p){
    if(p==="style") return {};
    if(p==="classList") return {add(){},remove(){},toggle(){},contains(){return false;}};
    if(p==="appendChild") return ()=>{};
    if(p==="removeChild") return ()=>{};
    if(p==="querySelector") return ()=>null;
    if(p==="querySelectorAll") return ()=>[];
    if(p==="setAttribute") return ()=>{};
    if(p==="removeAttribute") return ()=>{};
    if(p==="addEventListener") return ()=>{};
    if(p==="removeEventListener") return ()=>{};
    if(p==="focus") return ()=>{};
    if(p==="scrollIntoView") return ()=>{};
    return undefined;
  },
  set(_t,_p,_v){ return true; }
});
const $ = (id)=>document.getElementById(id) || __NULL_EL;
    /* ---------- Diagnostics / Safe Boot ---------- */
const __PF_DIAG = {
  errors: [],
  add(kind, err){
    const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err);
    const rec = {ts: new Date().toISOString(), kind, msg};
    this.errors.push(rec);
    if (this.errors.length > 50) this.errors.shift();
    try{ renderDiagBadge(); }catch(_){}
    try{ renderDiagPanel(); }catch(_){}
  }
};

function __safeCall(name, fn){ try{ return fn(); }catch(e){ __PF_DIAG.add(name, e); return null; } }

function ensureDiagPanel(){
  if (document.getElementById("diagPanel")) return;
  const wrap = document.createElement("div");
  wrap.id = "diagPanel";
  wrap.style.cssText = "position:fixed;left:12px;right:12px;bottom:76px;max-height:42vh;overflow:auto;z-index:9999;display:none;border:1px solid var(--border);background:var(--card);color:var(--text);border-radius:12px;box-shadow:var(--shadow);padding:12px";
  wrap.innerHTML = `
    <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:8px">
      <div style="font-weight:800">Diagnostics</div>
      <div style="display:flex;gap:8px">
        <button class="pill small" id="diagCopyBtn" type="button">Copy</button>
        <button class="pill small" id="diagCloseBtn" type="button">Close</button>
      </div>
    </div>
    <pre id="diagPre" style="white-space:pre-wrap;font-size:12px;line-height:1.35;margin:0"></pre>
  `;
  document.body.appendChild(wrap);
  (document.getElementById("diagCloseBtn")||__NULL_EL).onclick = ()=>{ wrap.style.display="none"; };
  (document.getElementById("diagCopyBtn")||__NULL_EL).onclick = ()=>{
    const txt = (document.getElementById("diagPre")||__NULL_EL).textContent || "";
    try{ navigator.clipboard.writeText(txt); }catch(_){}
  };
}

function renderDiagBadge(){
  // Add a tiny badge into the header if present (and make it clickable)
  const host = document.getElementById("diagBadgeHost");
  if (!host) return;

  // Make host act like a button
  host.setAttribute("role","button");
  host.tabIndex = 0;
  host.title = "Open diagnostics";

  // Toggle panel on click / keyboard
  host.onclick = ()=>{
    ensureDiagPanel();
    renderDiagPanel();
    const p = document.getElementById("diagPanel");
    if (!p) return;
    p.style.display = (p.style.display === "none" || !p.style.display) ? "block" : "none";
  };
  host.onkeydown = (e)=>{
    const k = e.key || "";
    if (k === "Enter" || k === " "){
      e.preventDefault();
      host.click();
    }
  };

  const n = __PF_DIAG.errors.length;
  host.textContent = n ? `⚠ ${n}` : "";
  host.style.display = n ? "inline-flex" : "none";
}
function renderDiagPanel(){
  ensureDiagPanel();
  const pre = document.getElementById("diagPre");
  if (!pre) return;
  const lines = __PF_DIAG.errors.slice(-10).map(e=>`[${e.ts}] ${e.kind}\n${e.msg}`).join("\n\n");
  pre.textContent = lines || "No errors captured.";
}

window.addEventListener("error", (ev)=>{
  __PF_DIAG.add("error", ev.error || (ev.message + " @ " + (ev.filename||"") + ":" + (ev.lineno||"")));
});
window.addEventListener("unhandledrejection", (ev)=>{
  __PF_DIAG.add("unhandledrejection", ev.reason || "Unhandled rejection");
});

// Safe toast host fallback: never allow toast() to crash init
function __ensureToastHost(){
  let h = document.getElementById("toastHost");
  if (!h){
    h = document.createElement("div");
    h.id = "toastHost";
    h.className = "toastHost";
    document.body.appendChild(h);
  }
  return h;
}

const deepClone = (o)=>JSON.parse(JSON.stringify(o));
    const escapeHtml = (s)=>String(s).replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));

    /* ---------- Toasts (2.5s) ---------- */
    const toastHost = __ensureToastHost();
    function toast(message, kind="ok", tag=""){
      const el = document.createElement("div");
      el.className = "toast" + (kind === "err" ? " err" : "");
      el.innerHTML = `<span class="dot"></span><span class="msg"></span>${tag ? `<span class="tag">${escapeHtml(tag)}</span>` : ""}`;
      el.querySelector(".msg").textContent = message;
      toastHost.appendChild(el);
      requestAnimationFrame(()=> el.classList.add("show"));
      setTimeout(()=>{
        el.classList.remove("show");
        setTimeout(()=> el.remove(), 150);
      }, 2500);
    }

    /* ---------- Drawer ---------- */
    function openDrawer(){ $("drawer").classList.add("open"); $("drawerBackdrop").classList.add("open"); }
    function closeDrawer(){ $("drawer").classList.remove("open"); $("drawerBackdrop").classList.remove("open"); }
    if ($("hamburgerBtn")) $("hamburgerBtn").onclick=openDrawer;
    if ($("barImport")) $("barImport").onclick=importTemplateOrPresetFromPicker;
    if ($("barApply")) $("barApply").onclick=applyChanges;
$("closeDrawer").onclick=closeDrawer;
    if ($("themeToggleBtn")) $("themeToggleBtn").onclick=()=>{
      const eff = getEffectiveTheme(themeMode);
      applyTheme(eff === "dark" ? "light" : "dark");
    };
    $("drawerBackdrop").onclick=closeDrawer;

    if ($("themeSelect")) $("themeSelect").onchange=()=>{
      applyTheme($("themeSelect").value || "auto");
    };

    /* ---------- Step accordion (only one open step) ---------- */
    const STEP_IDS = ["card0","card1","card2","card3","card4","cardOut"];
    function setupStepAccordion(){
      STEP_IDS.forEach(id=>{
        const det = $(id);
        if (!det) return;
        det.addEventListener("toggle", ()=>{
          if (!det.open) return;
          STEP_IDS.forEach(otherId=>{
            if (otherId !== id && $(otherId)) $(otherId).open = false;
          });
        });
      });
    }

    /* ---------- Changelog ---------- */
    const CHANGELOG = [
{
  'version': 'v1.2.1',
  'user_visible_changes': [
    'New header hamburger menu opens Actions drawer (replaces bottom Actions/Theme buttons).',
    'Simplified bottom bar: Generate, Copy, Import, Apply Changes.',
    'Removed Step 0/3/4 from UI; removed Step 1 apply buttons (use Apply Changes).',
    'Theme palettes updated (Dark: #000/#f79aaf/#ECECEC; Light: #FFF/#ea4c89/#444444).'
  ],
  'technical_notes': [
    'Added PFIS/RIS/external JSON import flow for Template/Preset with permission-gated conversion.'
  ]
},

{
  version: "v1.2.0",
  user_visible_changes: [
    "Added import for external prompt-description JSON (auto-detect + map into PromptForge editable doc).",
    "External imports preserve the original JSON under meta._import for audit + debugging."
  ],
  technical_notes: [
    "Introduced canonical internal document model (PF_INTERNAL_V1) as a stable target for cross-schema import mapping.",
    "Added lightweight self-tests for import mappers (console: window.PF_TESTS.run())."
  ]
},
{
  version: "v1.1.5",
  user_visible_changes: [
    "Fixed output/export pipeline crash (constraints union hardening).",
    "Added defensive fallbacks so Generate/Resets/Macros can't abort due to missing helpers."
  ],
  technical_notes: [
    "buildCanonicalDocForExport: constraints union now uses safe constraints object and _uniq fallback."
  ]
},
{
  version: "v1.1.4",
  user_visible_changes: [
    "Fixed fatal startup error that broke all controls (removed early references to themeMode/lockRunId during template initialization).",
    "Diagnostics badge is now clickable (opens/closes the Diagnostics panel; keyboard accessible).",
    "Restored templates/presets rendering, dropdowns, toggles, and buttons across the app."
  ],
  notes: [
    "If you ever see the ⚠ badge, tap it to open Diagnostics and copy the stack trace."
  ]
},

{
  version: "v1.1.1",
  user_visible_changes: [
    "Dark mode + Auto theme (system) with one-tap toggle; theme is persisted locally and included in bundles.",
    "Preset Manager in Actions drawer: filter + load + rename + delete user presets (built-ins are read-only).",
    "Repro control: Lock run ID toggle (+ New run ID button) to make outputs reproducible across edits.",
    "Output actions expanded: Copy JSON + Download prompt pack as .txt.",
    "Schema panel now includes 'Validate Now' (runs validation against current state).",
    "Fixed Sweeps button wiring (Run/Clear) and improved defensive state migrations (v1.0.x → v1.1.x)."
  ],
  non_user_visible_changes: [
    "Theme variables refactor: all UI surfaces now derive colors from CSS tokens to prevent contrast bugs in dark mode.",
    "Bundle format now round-trips appearance + reproducibility settings (theme_mode, lock_run_id)."
  ]
},
{
  version: "v1.0.1",
  user_visible_changes: [
    "Bundle import/export now round-trips full state (runs, strict validation, show-only-modified, auto-save-runs, Step 0 fields, baseline/baseData, selected preset).",
    "Preset apply now sets baseline (Reset Edits returns to the post-preset state).",
    "JSON import now sets baseline to imported doc (Reset Edits returns to imported state)."
  ],
  non_user_visible_changes: [
    "Hardened bundle format metadata and defensive caps on imported run history."
  ]
},
  {
    version: "v1.0.0",
    user_visible_changes: [
      "Added reference-images workflow: dedicated toggle + reference list/notes; prompt packs append ‘Reference images included’ when enabled.",
      "Added JSON Schema export (copy/save) + Validate Now action; new output modes: JSON Schema + Schema+JSON.",
      "Added productivity tools: macros (Hands-safe / No-text strict / Skin realism / Identity lock) and a sweep generator for parameter exploration.",
      "Expanded template set: Corporate headshot, Beauty close-up, Cinematic low-key, Street fashion, Fitness full-body, High-key studio, Golden hour outdoor, Film-grain editorial.",
      "Improved Prompt Pack compiler: stable section ordering, constraint alias sync, crop guards, stronger lint + strict validation toggle."
    ],
    non_user_visible_changes: [
      "Introduced schema identity: SCHEMA_ID_V1 + draft-2020-12 schema generator for registry paths.",
      "Added v1 defaults/shims (references, crop guards, constraint aliases) with migrations from v0.7/v0.8 localStorage keys.",
      "Hardened compile-time constraints: union of hard/negative aliases + enhanced negative token builder.",
      "Added sweep cache + per-variant prompt-hash for reproducible compare-and-pick workflows."
    ]
  },
  {
    version: "v0.8.0",
    user_visible_changes: [
      "New default output: Prompt Pack optimized for ChatGPT built-in image generation.",
      "Output: Copy Prompt Pack + Save to History buttons, plus lint panel for conflicts/quality traps.",
      "Expert UI: Show all schema fields (even if absent) + optional “Show only modified fields” filter.",
      "Runs drawer: local run history with export/clear; load prior JSON snapshots.",
      "JSON import now validates + quarantines unknown fields; safer merges throughout."
    ],
    non_user_visible_changes: [
      "Added Prompt Pack compiler (sectioned prompt, negative block, deterministic ordering).",
      "Added lint engine + JSON Patch diff export for reproducible edits.",
      "Safe deep-merge (prototype pollution hardened) and import quarantine.",
      "Schema path registry built from template union; inferred field types used for controls."
    ]
  },
  {
    version: "v0.7.0",
    user_visible_changes: [
      "Step 0: Merge & Seed (Name/Purpose/Prompt/JSON), Upload JSON, Copy Merged OUTPUT.",
      "Step 0: Inject into current state + Detect template from JSON toggles.",
      "Executable JSON header adds Name + Purpose (used as chat name / intent).",
      "Dropdown option descriptors (e.g., 4:5 — Instagram).",
      "Field “More” now shows selected-value description, recommendations, most common, reasoning."
    ],
    non_user_visible_changes: [
      "Enum option metadata model (short/long/recommendations/most_common/reasoning).",
      "Template detection heuristic for JSON ingest.",
      "Standardized meta fields: meta.app_name/meta.schema_version written on template apply."
    ]
  }
];

    function renderChangelog(){
      const body = $("changelogBody");
      const cur = (Array.isArray(CHANGELOG) && CHANGELOG.length) ? CHANGELOG[0] : null;
      if (!body || !cur){
        try{ if (body) body.innerHTML = ""; }catch(_){}
        return;
      }

      const u = Array.isArray(cur.user_visible_changes) ? cur.user_visible_changes : [];
      const nonArr =
        Array.isArray(cur.non_user_visible_changes) ? cur.non_user_visible_changes :
        Array.isArray(cur.technical_notes) ? cur.technical_notes :
        Array.isArray(cur.notes) ? cur.notes :
        [];

      const nonLabel =
        Array.isArray(cur.non_user_visible_changes) ? "NON_USER_VISIBLE_CHANGES" :
        Array.isArray(cur.technical_notes) ? "TECHNICAL_NOTES" :
        Array.isArray(cur.notes) ? "NOTES" :
        "NON_USER_VISIBLE_CHANGES";

      body.innerHTML = `
        <div class="small"><b>${escapeHtml(APP_NAME)} ${escapeHtml(cur.version || "")}</b></div>
        <div class="hr"></div>
        <div class="small"><b>USER_VISIBLE_CHANGES</b></div>
        <ul class="small" style="margin:8px 0 10px 18px; padding:0">
          ${u.map(x=>`<li>${escapeHtml(x)}</li>`).join("")}
        </ul>
        <div class="small"><b>${escapeHtml(nonLabel)}</b></div>
        <ul class="small" style="margin:8px 0 0 18px; padding:0">
          ${nonArr.map(x=>`<li>${escapeHtml(x)}</li>`).join("")}
        </ul>
      `;
    }

    function showChangelogIfNewVersion(){
      try{
        const last = localStorage.getItem(LS_LAST_SEEN) || "";
        if (last !== APP_VERSION){
          localStorage.setItem(LS_LAST_SEEN, APP_VERSION);
          openDrawer();
          $("drawerChangelog").open = true;
          toast("Changelog updated", "ok", (CHANGELOG && CHANGELOG[0] && CHANGELOG[0].version) ? CHANGELOG[0].version : APP_VERSION);
        }
      }catch(_){}
    }

    /* ---------- Path helpers ---------- */
    function getByPath(obj, path){ return path.split(".").reduce((o,k)=> (o ? o[k] : undefined), obj); }
    function setByPath(obj, path, value){
      const parts = path.split(".");
      let cur = obj;
      for (let i=0;i<parts.length-1;i++){
        if (!(parts[i] in cur) || cur[parts[i]] === null) cur[parts[i]] = {};
        cur = cur[parts[i]];
      }
      cur[parts[parts.length-1]] = value;
    }
    function ensureArrayContains(obj, path, item){
      const arr = getByPath(obj, path);
      if (!Array.isArray(arr)) setByPath(obj, path, []);
      const a2 = getByPath(obj, path);
      if (!a2.includes(item)) a2.push(item);
    }

    // Remove a value at a dotted path (best-effort; used for meta cleanup)
    function deleteByPath(obj, path){
      if (!obj || typeof obj !== "object") return;
      const parts = String(path||"").split(".").filter(Boolean);
      if (!parts.length) return;
      let cur = obj;
      for (let i=0;i<parts.length-1;i++){
        if (!cur || typeof cur !== "object") return;
        cur = cur[parts[i]];
      }
      if (cur && typeof cur === "object"){
        try{ delete cur[parts[parts.length-1]]; }catch(_){}
      }
    }

    // Stable unique list helper (trim strings, drop empties)
    function uniq(arr){
      const out = [];
      const seen = new Set();
      for (const v of (Array.isArray(arr) ? arr : [])){
        if (v === undefined || v === null) continue;
        const isStr = (typeof v === "string");
        const val = isStr ? v.trim() : v;
        const key = isStr ? val : JSON.stringify(val);
        if (!key) continue;
        if (seen.has(key)) continue;
        seen.add(key);
        out.push(val);
      }
      return out;
    }
    const BLOCKED_KEYS = new Set(["__proto__","prototype","constructor"]);
function isPlainObject(x){ return !!x && typeof x === "object" && !Array.isArray(x); }

// Safe deep merge (hardened against prototype pollution). Arrays replace by default.
function deepMerge(target, source){
  if (!isPlainObject(target) || !isPlainObject(source)) return;
  for (const k of Object.keys(source)){
    if (BLOCKED_KEYS.has(k)) continue;
    const sv = source[k];
    if (Array.isArray(sv)){
      target[k] = sv.slice();
      continue;
    }
    if (isPlainObject(sv)){
      if (!isPlainObject(target[k])) target[k] = {};
      deepMerge(target[k], sv);
      continue;
    }
    target[k] = sv;
  }
}

    /* ---------- Strip empties ---------- */
    function stripEmpties(value){
      if (Array.isArray(value)){
        const arr = value.map(stripEmpties).filter(v => !(v === undefined || v === null || v === "" || (Array.isArray(v) && v.length===0)));
        return arr.length ? arr : undefined;
      }
      if (value && typeof value === "object"){
        const out = {};
        for (const [k,v] of Object.entries(value)){
          const sv = stripEmpties(v);
          if (sv === undefined) continue;
          out[k] = sv;
        }
        return Object.keys(out).length ? out : undefined;
      }
      return (value === "" || value === null || value === undefined) ? undefined : value;
    }


/* ---------- Deterministic serialization + ids ---------- */
function stableStringify(value){
  const seen = new WeakSet();
  const helper = (v)=>{
    if (v === null || v === undefined) return v;
    if (typeof v !== "object") return v;
    if (seen.has(v)) return "[Circular]";
    seen.add(v);
    if (Array.isArray(v)) return v.map(helper);
    const out = {};
    Object.keys(v).sort().forEach(k=>{
      if (BLOCKED_KEYS && BLOCKED_KEYS.has(k)) return;
      out[k] = helper(v[k]);
    });
    return out;
  };
  return JSON.stringify(helper(value));
}

function fnv1a32(str){
  // Deterministic non-crypto hash (prompt-only reproducibility; NOT a seed).
  let h = 0x811c9dc5;
  for (let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = (h + ((h<<1) + (h<<4) + (h<<7) + (h<<8) + (h<<24))) >>> 0;
  }
  return ("0000000" + h.toString(16)).slice(-8);
}

function uuidv4(){
  // RFC4122 v4-ish. Uses crypto if available.
  const g = (n)=>Array.from({length:n}, ()=>Math.floor(Math.random()*256));
  let bytes;
  if (globalThis.crypto?.getRandomValues){
    bytes = new Uint8Array(16);
    globalThis.crypto.getRandomValues(bytes);
  } else {
    bytes = Uint8Array.from(g(16));
  }
  bytes[6] = (bytes[6] & 0x0f) | 0x40;
  bytes[8] = (bytes[8] & 0x3f) | 0x80;
  const hex = [...bytes].map(b=>b.toString(16).padStart(2,"0")).join("");
  return `${hex.slice(0,8)}-${hex.slice(8,12)}-${hex.slice(12,16)}-${hex.slice(16,20)}-${hex.slice(20)}`;
}

function deepEqual(a,b){
  // Good-enough structural equality for this tool (strings/arrays/objects)
  return stableStringify(a) === stableStringify(b);
}

function uniqNorm(arr){
  const out = [];
  const seen = new Set();
  (arr||[]).forEach(x=>{
    const s = String(x||"").trim();
    if (!s) return;
    const key = s.toLowerCase();
    if (seen.has(key)) return;
    seen.add(key);
    out.push(s);
  });
  return out;
}

    /* ---------- Clipboard ---------- */
    async function copyToClipboard(text){
      try{
        if (navigator.clipboard && navigator.clipboard.writeText){
          await navigator.clipboard.writeText(text);
          return true;
        }
      }catch(_){}
      try{
        const ta = document.createElement("textarea");
        ta.value = text;
        ta.setAttribute("readonly", "");
        ta.style.position = "fixed";
        ta.style.left = "-9999px";
        ta.style.top = "0";
        document.body.appendChild(ta);
        ta.focus(); ta.select();
        ta.setSelectionRange(0, ta.value.length);
        const ok = document.execCommand("copy");
        document.body.removeChild(ta);
        return !!ok;
      }catch(_){
        return false;
      }
    }

    /* ---------- Prompt generator + custom image type ---------- */
    const IMAGE_ANALYSIS_PROMPTS = {
      "Portrait Photography": `You will receive an image.\nAnalyze it and convert EVERYTHING visible into a complete Ultra Elite JSON structure.\nRules:\n- Use Ultra Elite template structure\n- Preserve identity exactly\n- Extract facial structure, skin micro detail, lighting physics, camera properties\n- Capture environment, clothing, accessories, pose, mood\n- Fill every field possible\n- Unknown fields: infer realistically\nOutput ONLY JSON.\nIf image not provided ask for image.`,
      "Full Body Fashion": `Analyze uploaded fashion image.\nExtract garments, fabric physics, body proportions, pose, materials, studio lighting.\nReturn Ultra Elite JSON.\nOutput only JSON.\nIf no image, request image.`,
      "Anime": `Analyze anime illustration.\nExtract art style, line weight, shading model, palette, character design.\nMap to Ultra Elite JSON (stylized).\nOutput only JSON.\nIf no image present ask for image.`,
      "3D Render": `Analyze 3D render.\nExtract geometry, materials, lighting, rendering characteristics.\nReturn Ultra Elite JSON.\nOutput only JSON.\nIf image missing request image.`,
      "Wallpapers": `Analyze wallpaper image.\nExtract composition, environment, palette, lighting, atmosphere.\nReturn Ultra Elite JSON.\nOutput only JSON.`,
      "Product Photography": `Analyze product image.\nExtract object geometry, material properties, reflections, studio setup.\nReturn Ultra Elite JSON.\nOutput only JSON.`,
      "Social Media Image": `Analyze social-media style image.\nExtract aesthetic style, filters, pose, framing, intent.\nReturn Ultra Elite JSON.\nOutput only JSON.`,
      "Poster / Graphic Design": `Analyze poster/graphic.\nExtract layout structure, typography presence, color design.\nReturn Ultra Elite JSON.\nOutput only JSON.`,
      "Landscape Photography": `Analyze landscape.\nExtract environment physics, atmosphere, weather, lighting.\nReturn Ultra Elite JSON.\nOutput only JSON.`,
      "Realistic Illustration": `Analyze realistic illustration.\nExtract rendering technique, texture, lighting.\nReturn Ultra Elite JSON.\nOutput only JSON.`,
      "Custom": ""
    };

    /* ---------- Templates ---------- */
    const TEMPLATE_INFO = {
      "ChatGPT Optimized": "General-purpose best default. Balanced portrait/fashion output.",
      "Headshot (Corporate)": "Tight, clean corporate headshot. Neutral studio background, minimal artifacts.",
      "Beauty Close-Up": "High-detail beauty close-up emphasizing natural skin texture and crisp eyes.",
      "Cinematic Low-Key": "Moody low-key portrait with cinematic lighting and controlled contrast.",
      "Street Fashion": "Editorial street-fashion portrait with realistic outdoor lighting and clean subject separation.",
      "Fitness Full-Body": "Full-body athletic shot with strong framing guards for hands/feet and anatomy.",
      "High-Key Studio": "Bright high-key studio portrait optimized for clarity and minimal noise.",
      "Golden Hour Outdoor": "Warm golden-hour outdoor portrait with natural lighting and flattering color.",
      "Film Grain Editorial": "Editorial portrait with subtle film grain and analog-inspired color pipeline.",
      "Single Image": "Best for one-off impact shots and full-body images.",
      "Consistent Character": "Best for identity stability across multiple generations.",
      "Ultra Elite (ChatGPT5.2)": "Superset control schema. Enables Step 4 (God Mode)."
    };

    const TEMPLATE_BASES = (function(){
      const base = {
        "ChatGPT Optimized": {
          meta: { app_name: APP_NAME,
 schema_version: APP_VERSION, engine_target: "chatgpt", template_type: "chatgpt_optimized" },
          prompt_profile: {
            mode: "photoreal",
            priority: ["composition","subject","clothing","accessories","lighting","background","style","camera","constraints"],
            output_goal: "single photoreal image with clean detail, consistent anatomy, no text/logos/watermarks"
          },
          output_specs: { num_subjects: 1, aspect_ratio: "4:5", resolution_hint: "high" },
          composition: {
            shot_type: "editorial portrait",
            body_visibility: "waist-up",
            framing: "waist-up portrait, include hands if possible, clean crop",
            orientation: "vertical",
            subject_position: "center",
            camera_height: "eye level",
            camera_distance: "medium",
            perspective: "neutral",
            background_blur_intent: "moderate"
          },
          identity: {
            identity_strength: "medium",
            distinctive_features: "consistent facial proportions, consistent eye shape, consistent jawline",
            variation_seed: "seed-1001",
            do_not_change: ["face shape","eye shape","jawline","hair color"]
          },
          subject: {
            gender: "female",
            age: "young adult",
            ethnicity: "unspecified",
            skin: { tone: "light", undertone: "neutral", texture: "natural skin texture", details: "visible pores, subtle imperfections" },
            face: { shape: "oval", features: "defined cheekbones, straight nose, balanced proportions" },
            eyes: { color: "brown", makeup: "natural soft makeup" },
            hair: { color: "dark brown", style: "loose waves", details: "realistic strand detail" }
          },
          clothing: {
            top: "black turtleneck",
            bottom: "high-waisted jeans",
            outerwear: "none",
            dress: "none",
            footwear: "none",
            materials: ["cotton","denim"],
            fit: "tailored",
            style: "smart casual",
            notes: "wrinkle-natural, realistic fabric texture"
          },
          accessories: { items: ["none"], details: "no jewelry" },
          lighting: { type: "studio softbox", direction: "front", quality: "soft", tone: "neutral", notes: "gentle shadows, flattering key light" },
          background: { location_type: "studio", scene: "minimal seamless backdrop", clutter: "minimal", complexity: "low", palette: "neutral" },
          style: { genre: "fashion", strength: "medium", realism_strength: "high", color_grading: "neutral", contrast: "medium", sharpness: "high" },
          camera: { photo_style: "editorial portrait", focal_length: "85mm", depth_of_field: "shallow", exposure: "balanced", grain: "subtle" },
          mood: "calm, confident",
          constraints: {
            must_include: ["no text","no logos","no watermarks","accurate hands","natural skin texture"],
            avoid: ["extra fingers","warped hands","deformed anatomy","blurred face","plastic skin","over-smoothed skin","AI artifacts"]
          },
          prompt_output: { user_prefix: "", negative_prompt: "" }
        },
        "Single Image": {
          meta: { app_name: APP_NAME, schema_version: APP_VERSION, engine_target: "chatgpt", template_type: "single_image" },
          prompt_profile: {
            mode: "photoreal",
            priority: ["composition","subject","clothing","lighting","background","camera","style","constraints"],
            output_goal: "one-off image optimized for impact; clean composition; no text/logos/watermarks"
          },
          output_specs: { num_subjects: 1, aspect_ratio: "9:16", resolution_hint: "high" },
          composition: {
            shot_type: "full-body lifestyle",
            body_visibility: "full body",
            framing: "head-to-toe visible, include shoes, include hands",
            orientation: "vertical",
            subject_position: "center",
            camera_height: "eye level",
            camera_distance: "far",
            perspective: "neutral",
            background_blur_intent: "light"
          },
          identity: { identity_strength: "low", distinctive_features: "pleasant natural face, realistic proportions", variation_seed: "seed-2001", do_not_change: [] },
          subject: {
            gender: "female",
            age: "young adult",
            ethnicity: "unspecified",
            skin: { tone: "medium", undertone: "neutral", texture: "natural", details: "subtle pores, realistic specular highlights" },
            face: { shape: "oval", features: "balanced proportions" },
            eyes: { color: "brown", makeup: "light natural makeup" },
            hair: { color: "dark brown", style: "straight", details: "realistic strands" }
          },
          clothing: { top: "white t-shirt", bottom: "tailored trousers", outerwear: "none", dress: "none", footwear: "sneakers", materials: ["cotton"], fit: "relaxed", style: "casual", notes:"clean minimal look" },
          accessories: { items: ["none"], details: "" },
          lighting: { type: "natural daylight", direction: "side", quality: "soft", tone: "neutral", notes: "soft shadows" },
          background: { location_type: "outdoor", scene: "clean street background, minimal distractions", clutter: "minimal", complexity: "medium", palette: "neutral" },
          style: { genre: "lifestyle", strength: "medium", realism_strength: "high", color_grading: "neutral", contrast: "medium", sharpness:"high" },
          camera: { photo_style: "full-body street portrait", focal_length: "50mm", depth_of_field: "medium", exposure: "balanced", grain:"subtle" },
          mood: "relaxed",
          constraints: { must_include: ["no text","no logos","no watermarks","accurate hands","natural skin texture"], avoid: ["extra fingers","warped hands","deformed anatomy","AI artifacts","over-smoothing"] },
          prompt_output: { user_prefix: "", negative_prompt: "" }
        },
        "Consistent Character": {
          meta: { app_name: APP_NAME, schema_version: APP_VERSION, engine_target: "chatgpt", template_type: "consistent_character" },
          prompt_profile: {
            mode: "photoreal",
            priority: ["identity","subject","composition","clothing","lighting","background","camera","style","constraints"],
            output_goal: "consistent character identity across images; strict facial stability; no text/logos/watermarks"
          },
          output_specs: { num_subjects: 1, aspect_ratio: "4:5", resolution_hint: "high" },
          composition: {
            shot_type: "portrait series",
            body_visibility: "waist-up",
            framing: "waist-up portrait, include hands if possible",
            orientation: "vertical",
            subject_position: "center",
            camera_height: "eye level",
            camera_distance: "medium",
            perspective: "neutral",
            background_blur_intent: "moderate"
          },
          identity: {
            identity_strength: "high",
            distinctive_features: "consistent facial proportions and eye spacing, consistent jawline, consistent hairline",
            variation_seed: "seed-CC-3001",
            do_not_change: ["face shape","eye shape","jawline","hair color","eye color","skin tone"]
          },
          subject: {
            gender: "female",
            age: "young adult",
            ethnicity: "unspecified",
            skin: { tone: "light", undertone: "neutral", texture: "natural skin texture", details: "visible pores, subtle imperfections, realistic sheen" },
            face: { shape: "oval", features: "defined jawline, straight nose, stable cheekbones" },
            eyes: { color: "brown", makeup: "natural" },
            hair: { color: "dark brown", style: "loose waves", details: "consistent hairline and strand detail" }
          },
          clothing: { top: "black turtleneck", bottom: "none", outerwear: "none", dress: "none", footwear: "none", materials: ["cotton"], fit: "tailored", style: "smart casual", notes:"keep consistent between images unless changed deliberately" },
          accessories: { items: ["none"], details: "" },
          lighting: { type: "studio softbox", direction: "front", quality: "soft", tone: "neutral", notes:"consistent key light across images" },
          background: { location_type: "studio", scene: "minimal seamless backdrop", clutter: "minimal", complexity: "low", palette:"neutral" },
          style: { genre: "editorial", strength: "medium", realism_strength: "high", color_grading: "neutral", contrast: "medium", sharpness:"high" },
          camera: { photo_style: "consistent portrait series", focal_length: "85mm", depth_of_field: "shallow", exposure:"balanced", grain:"subtle" },
          mood: "neutral",
          constraints: { must_include: ["no text","no logos","no watermarks","accurate hands","natural skin texture","strict identity lock"], avoid: ["extra fingers","warped hands","deformed anatomy","blurred face","plastic skin","identity drift","AI artifacts"] },
          prompt_output: { user_prefix: "", negative_prompt: "" }
        },
        "Ultra Elite (ChatGPT5.2)": {
          meta: { app_name: APP_NAME, schema_version: APP_VERSION, engine_target: "chatgpt", template_type: "ultra_elite" },
          system_profile: { engine: "chatgpt-5.2", mode: "ultra_elite", generation_intent: "maximum controllability" },
          prompt_profile: {
            mode: "photoreal",
            priority: ["subject.identity","subject.clothing","composition","environment","lighting","camera","rendering","color_pipeline","constraints"],
            output_goal: "maximum controllability, physically plausible lighting/materials, strict identity preservation, no text/logos/watermarks"
          },
          subject: {
            identity: {
              core_description: "photoreal young adult woman with balanced facial proportions",
              age: "young adult",
              gender: "female",
              ethnicity: "unspecified",
              facial_structure: {
                face_shape: "oval",
                skull_structure: "balanced cranial proportions",
                jawline: "defined but natural",
                cheekbones: "moderately high cheekbones",
                nose_shape: "straight nose",
                eye_shape: "almond-shaped eyes",
                eyebrow_shape: "natural arched eyebrows"
              },
              skin: {
                tone: "light",
                undertone: "neutral",
                texture: "natural skin texture",
                pores: "visible pores",
                imperfections: "subtle imperfections",
                subsurface_scattering: "realistic subsurface scattering"
              },
              hair: {
                color: "dark brown",
                strand_detail: "high strand fidelity",
                density: "medium-high density",
                style: "loose waves",
                physics: "natural hair physics with gravity and subtle flyaways"
              },
              body: {
                proportions: "realistic proportions",
                build: "slim-athletic",
                posture: "neutral confident posture",
                biomechanics: "anatomically plausible"
              },
              identity_lock: true
            },
            clothing: {
              garments: ["black turtleneck","high-waisted jeans"],
              materials: ["cotton","denim"],
              fabric_behavior: "natural wrinkles, realistic drape",
              wear_state: "clean",
              micro_detail: "visible stitching and fabric grain"
            },
            accessories: { items: ["none"], materials: [], reflections: "physically plausible reflections (if applicable)" }
          },
          composition: {
            framing: "waist-up portrait, clean crop, include hands if possible",
            rule_of_thirds: "centered with subtle rule-of-thirds balance",
            subject_priority: "subject is dominant focal point",
            spatial_depth: "moderate depth separation",
            negative_space: "minimal",
            visual_weight: "balanced"
          },
          environment: {
            location: "studio",
            architecture: "minimal seamless backdrop",
            atmosphere: "clean air, no haze",
            particles: "none",
            weather: "none",
            physics_interaction: "subject casts realistic contact shadows"
          },
          lighting: {
            sources: ["softbox key light", "soft fill light"],
            global_illumination: "soft global illumination",
            shadow_behavior: "soft realistic shadows",
            reflections: "controlled highlights",
            volumetrics: "none"
          },
          camera: {
            model_simulation: "full-frame DSLR look",
            sensor_size: "full-frame",
            lens_model: "85mm portrait lens",
            optical_aberrations: "subtle vignetting, minimal distortion",
            focus_behavior: "sharp eyes, shallow depth of field",
            exposure_pipeline: "balanced exposure with protected highlights"
          },
          rendering: {
            realism_level: "high photorealism",
            material_model: "physically-based materials",
            texture_resolution: "high",
            ray_tracing: "implied realistic light transport",
            motion_blur: "none",
            noise_profile: "clean with subtle film grain"
          },
          color_pipeline: {
            color_space: "sRGB",
            dynamic_range: "high",
            tone_mapping: "natural highlight rolloff",
            grading_profile: "neutral editorial grade"
          },
          constraints: {
            must_include: ["no text","no logos","no watermarks","accurate hands","natural skin texture","strict identity lock"],
            avoid: ["extra fingers","warped hands","deformed anatomy","blurred face","plastic skin","identity drift","AI artifacts"],
            preservation_lock: true
          },
          prompt_output: { user_prefix: "", negative_prompt: "" }
        }
      };

      // Derived templates (minimize duplication)
      const addT = (name, from, overlay)=>{
        base[name] = deepClone(base[from]);
        deepMerge(base[name], overlay);
        // normalize meta
        base[name].meta = base[name].meta || {};
        base[name].meta.app_name = APP_NAME;
        base[name].meta.schema_version = APP_VERSION;
        base[name].meta.engine_target = "chatgpt";
        if (!base[name].meta.template_type) base[name].meta.template_type = "person_shot";
        return base[name];
      };

      addT("Headshot (Corporate)", "ChatGPT Optimized", {
        output_specs:{ aspect_ratio:"1:1" },
        composition:{ shot_type:"corporate headshot", body_visibility:"close-up", framing:"tight headshot, eyes centered, include shoulders, clean crop", orientation:"square", crop_guards:{ hands:false, feet:false, headroom:"tight" } },
        background:{ location_type:"studio", scene:"neutral seamless backdrop, subtle gradient", clutter:"minimal", complexity:"low" },
        lighting:{ type:"studio softbox", direction:"front", quality:"soft", tone:"neutral" },
        camera:{ focal_length:"85mm", depth_of_field:"shallow", angle:"eye-level" },
        style:{ genre:"corporate", color_grading:"neutral", contrast:"medium" },
        constraints:{ must_include:["no text","no logos","no watermarks","natural skin texture","sharp eyes"], avoid:["extra fingers","warped hands","deformed anatomy","blurred face","plastic skin","AI artifacts"] },
        references:{ images_included:false, images:[], notes:"" }
      });

      addT("Beauty Close-Up", "ChatGPT Optimized", {
        output_specs:{ aspect_ratio:"4:5" },
        composition:{ shot_type:"beauty close-up", body_visibility:"close-up", framing:"tight face close-up, eyes centered, crisp eyelashes, detailed skin texture", orientation:"vertical", crop_guards:{ hands:false, feet:false, headroom:"tight" } },
        lighting:{ type:"beauty dish soft light", direction:"front", quality:"soft", tone:"neutral" },
        camera:{ focal_length:"105mm", depth_of_field:"shallow", angle:"eye-level" },
        style:{ genre:"beauty editorial", color_grading:"clean neutral", contrast:"medium" },
        constraints:{ must_include:["no text","no logos","no watermarks","natural skin texture","no plastic skin","sharp eyes"], avoid:["blurred face","over-smoothed skin","AI artifacts","distorted eyes","asymmetrical facial features"] },
        references:{ images_included:false, images:[], notes:"" }
      });

      addT("Cinematic Low-Key", "ChatGPT Optimized", {
        output_specs:{ aspect_ratio:"16:9" },
        composition:{ shot_type:"cinematic portrait", body_visibility:"waist-up", framing:"waist-up cinematic portrait, allow slight environment, keep face dominant", orientation:"horizontal", crop_guards:{ hands:false, feet:false, headroom:"normal" } },
        lighting:{ type:"cinematic low-key", direction:"side", quality:"soft with hard edge", tone:"moody" },
        background:{ location_type:"indoor", scene:"dark minimal background with subtle bokeh", clutter:"minimal", complexity:"low" },
        camera:{ focal_length:"50mm", depth_of_field:"shallow", angle:"eye-level" },
        style:{ genre:"cinematic", color_grading:"cinematic", contrast:"high" },
        constraints:{ must_include:["no text","no logos","no watermarks","clean shadows","natural skin texture"], avoid:["noise","banding","blurred face","plastic skin","AI artifacts"] },
        references:{ images_included:false, images:[], notes:"" }
      });

      addT("Street Fashion", "ChatGPT Optimized", {
        output_specs:{ aspect_ratio:"4:5" },
        composition:{ shot_type:"street fashion", body_visibility:"3/4 body", framing:"3/4 body street-fashion portrait, include hands, clean crop", orientation:"vertical", crop_guards:{ hands:true, feet:false, headroom:"normal" } },
        background:{ location_type:"outdoor", scene:"clean city street background, minimal distractions", clutter:"minimal", complexity:"medium" },
        lighting:{ type:"natural daylight", direction:"side", quality:"soft", tone:"neutral" },
        camera:{ focal_length:"50mm", depth_of_field:"medium", angle:"eye-level" },
        style:{ genre:"fashion editorial", color_grading:"neutral", contrast:"medium" },
        constraints:{ must_include:["no text","no logos","no watermarks","accurate hands","natural skin texture"], avoid:["extra fingers","warped hands","deformed anatomy","AI artifacts"] },
        references:{ images_included:false, images:[], notes:"" }
      });

      addT("Fitness Full-Body", "Single Image", {
        output_specs:{ aspect_ratio:"9:16" },
        composition:{ shot_type:"fitness full-body", body_visibility:"full body", framing:"head-to-toe visible, include shoes, include hands, athletic stance", orientation:"vertical", crop_guards:{ hands:true, feet:true, headroom:"normal" } },
        background:{ location_type:"indoor", scene:"modern gym or clean studio, minimal clutter", clutter:"minimal", complexity:"medium" },
        lighting:{ type:"studio hard-soft mix", direction:"side", quality:"crisp", tone:"neutral" },
        camera:{ focal_length:"35mm", depth_of_field:"medium", angle:"eye-level" },
        style:{ genre:"fitness", color_grading:"neutral", contrast:"high" },
        constraints:{ must_include:["no text","no logos","no watermarks","accurate hands","accurate feet","natural skin texture"], avoid:["extra fingers","warped hands","deformed anatomy","blurred face","AI artifacts"] },
        references:{ images_included:false, images:[], notes:"" }
      });

      addT("High-Key Studio", "ChatGPT Optimized", {
        output_specs:{ aspect_ratio:"4:5" },
        composition:{ shot_type:"high-key studio portrait", body_visibility:"waist-up", framing:"waist-up portrait, bright background, clean crop", orientation:"vertical", crop_guards:{ hands:false, feet:false, headroom:"normal" } },
        background:{ location_type:"studio", scene:"pure white seamless backdrop", clutter:"minimal", complexity:"low" },
        lighting:{ type:"high-key softbox", direction:"front", quality:"soft", tone:"bright neutral" },
        camera:{ focal_length:"85mm", depth_of_field:"shallow", angle:"eye-level" },
        style:{ genre:"editorial", color_grading:"clean", contrast:"low" },
        constraints:{ must_include:["no text","no logos","no watermarks","clean whites","natural skin texture"], avoid:["blown highlights","posterization","plastic skin","AI artifacts"] },
        references:{ images_included:false, images:[], notes:"" }
      });

      addT("Golden Hour Outdoor", "ChatGPT Optimized", {
        output_specs:{ aspect_ratio:"4:5" },
        composition:{ shot_type:"golden-hour portrait", body_visibility:"waist-up", framing:"waist-up portrait, warm golden-hour rim, clean crop", orientation:"vertical", crop_guards:{ hands:false, feet:false, headroom:"normal" } },
        background:{ location_type:"outdoor", scene:"soft background greenery or urban park, minimal distractions", clutter:"minimal", complexity:"medium" },
        lighting:{ type:"golden hour natural light", direction:"back", quality:"soft", tone:"warm" },
        camera:{ focal_length:"85mm", depth_of_field:"shallow", angle:"eye-level" },
        style:{ genre:"lifestyle", color_grading:"warm natural", contrast:"medium" },
        constraints:{ must_include:["no text","no logos","no watermarks","natural skin texture"], avoid:["orange skin","over-saturation","AI artifacts"] },
        references:{ images_included:false, images:[], notes:"" }
      });

      addT("Film Grain Editorial", "ChatGPT Optimized", {
        output_specs:{ aspect_ratio:"3:4" },
        composition:{ shot_type:"editorial portrait", body_visibility:"waist-up", framing:"waist-up editorial portrait, subtle off-center composition, clean crop", orientation:"vertical", crop_guards:{ hands:false, feet:false, headroom:"normal" } },
        lighting:{ type:"soft directional", direction:"side", quality:"soft", tone:"neutral" },
        camera:{ focal_length:"50mm", depth_of_field:"medium", angle:"eye-level" },
        style:{ genre:"editorial", color_grading:"analog film emulation", contrast:"medium" },
        rendering:{ quality:"high", grain:"subtle film grain" },
        constraints:{ must_include:["no text","no logos","no watermarks","subtle film grain","natural skin texture"], avoid:["digital noise","plastic skin","AI artifacts"] },
        references:{ images_included:false, images:[], notes:"" }
      });
      return base;
    })();

    /* ---------- Presets ---------- */
    function applyNeutralBlueprint(data){
      const setIfBlank = (path, val) => {
        const cur = getByPath(data, path);
        if (cur === undefined || cur === null || cur === "" || (Array.isArray(cur) && cur.length===0)) setByPath(data, path, val);
      };
      setIfBlank("background.location_type","studio");
      setIfBlank("background.scene","minimal seamless backdrop");
      setIfBlank("background.clutter","minimal");
      setIfBlank("background.complexity","low");
      setIfBlank("lighting.type","studio softbox");
      setIfBlank("lighting.direction","front");
      setIfBlank("lighting.quality","soft");
      setIfBlank("lighting.tone","neutral");
      setIfBlank("style.color_grading","neutral");
      setIfBlank("style.contrast","medium");
      setIfBlank("camera.focal_length","85mm");
      setIfBlank("camera.depth_of_field","shallow");
      ensureArrayContains(data, "constraints.must_include", "no text");
      ensureArrayContains(data, "constraints.must_include", "no logos");
      ensureArrayContains(data, "constraints.must_include", "no watermarks");
      ensureArrayContains(data, "constraints.avoid", "extra fingers");
      ensureArrayContains(data, "constraints.avoid", "warped hands");
    }

    const BUILTIN_PRESETS = [
      { name: "— None —", kind:"none", apply: (data)=>data },
      { name: "BNP Full Body", kind:"builtin", apply: (data)=>{ applyNeutralBlueprint(data); setByPath(data,"composition.body_visibility","full body"); setByPath(data,"composition.framing","head-to-toe visible, include shoes, include hands"); return data; } },
      { name: "BNP Waist-up", kind:"builtin", apply: (data)=>{ applyNeutralBlueprint(data); setByPath(data,"composition.body_visibility","waist-up"); setByPath(data,"composition.framing","waist-up portrait, include hands if possible"); return data; } },
      { name: "BNP Close-up", kind:"builtin", apply: (data)=>{ applyNeutralBlueprint(data); setByPath(data,"composition.body_visibility","close-up"); setByPath(data,"composition.framing","tight face close-up, eyes centered"); return data; } },
      { name: "BNP Cinematic", kind:"builtin", apply: (data)=>{ applyNeutralBlueprint(data); setByPath(data,"style.genre","cinematic"); setByPath(data,"style.color_grading","cinematic"); setByPath(data,"lighting.type","cinematic lighting"); return data; } }
    ];

    /* ---------- Value metadata (dropdown descriptors + More box) ---------- */
    const VALUE_INFO = {
      "output_specs.aspect_ratio": {
        "4:5": {
          short: "Instagram feed portrait",
          long: "A strong default for portraits. Crops well for social feeds without extreme vertical stretch.",
          recommendations: ["Use for portraits/upper body", "Keeps headroom manageable", "Pairs well with 85mm look"],
          most_common: "Most common for portrait/fashion feed images.",
          reasoning: "Provides a balanced portrait canvas; fewer composition failures than 9:16."
        },
        "9:16": {
          short: "Reels/Stories vertical",
          long: "Tall vertical frame optimized for full-body, reels, stories, and mobile-first viewing.",
          recommendations: ["Use for full-body and dynamic poses", "Be explicit about feet/hands visibility"],
          most_common: "Common for mobile full-body and social vertical content.",
          reasoning: "Maximizes vertical real estate; increases risk of awkward limbs unless constraints are explicit."
        },
        "1:1": {
          short: "Square",
          long: "Square canvas for balanced compositions, product, avatars, and thumbnails.",
          recommendations: ["Use for icons, product, profile shots", "Keep subject centered"],
          most_common: "Common for thumbnails and square platforms.",
          reasoning: "Predictable framing; reduces composition variability."
        },
        "16:9": {
          short: "Widescreen",
          long: "Landscape cinematic framing. Strong for environments and wide scenes.",
          recommendations: ["Use for landscapes, groups, environments", "Reduce close-up portrait intent"],
          most_common: "Common for landscape/environment shots.",
          reasoning: "Widescreen emphasizes environment; portrait subjects can feel small unless framed carefully."
        },
        "3:4": {
          short: "Classic portrait",
          long: "A classic portrait ratio; slightly less tall than 4:5.",
          recommendations: ["Use if you want a bit more breathing room horizontally"],
          most_common: "Less common than 4:5 but useful.",
          reasoning: "Sits between square and 4:5."
        }
      }
    };

    const FIELD_META = {
      "output_specs.aspect_ratio": {
        label:"Aspect ratio",
        category:"Output & Prompt",
        desc:"Output framing. Choose based on use-case (feed, stories, landscape).",
        suggestions:["1:1","4:5","3:4","9:16","16:9"]
      },
      "composition.body_visibility": { label:"Body visibility", category:"Composition", desc:"How much of the body is visible in frame.", suggestions:["full body","3/4 body","waist-up","close-up"] },
      "composition.framing": { label:"Framing", category:"Composition", desc:"Precise framing rules. Include hands/shoes when needed.", suggestions:["waist-up portrait, include hands if possible, clean crop","head-to-toe visible, include shoes, include hands","tight face close-up, eyes centered"] },
      "composition.orientation": { label:"Orientation", category:"Composition", desc:"Canvas orientation.", suggestions:["vertical","horizontal","square"] },
      "subject.gender": { label:"Gender", category:"Subject", desc:"Subject gender identity (optional).", suggestions:["female","male","(omit)"] },
      "subject.age": { label:"Age", category:"Subject", desc:"Age range descriptor.", suggestions:["teen","young adult","adult","middle-aged","elderly"] },
      "subject.ethnicity": { label:"Ethnicity", category:"Subject", desc:"Optional. Recommended: unspecified unless required.", suggestions:["unspecified","White","Black","East Asian","South Asian","Hispanic/Latino","Middle Eastern/North African"] },
      "clothing.top": { label:"Top", category:"Clothing", desc:"Upper garment.", suggestions:["black turtleneck","white t-shirt","silk blouse","oversized hoodie","none"] },
      "clothing.bottom": { label:"Bottom", category:"Clothing", desc:"Lower garment.", suggestions:["high-waisted jeans","tailored trousers","pleated skirt","none"] },
      "camera.focal_length": { label:"Focal length", category:"Camera", desc:"Lens feel. 85mm is flattering for portraits.", suggestions:["35mm","50mm","85mm","105mm","50–85mm"] },
      "camera.depth_of_field": { label:"Depth of field", category:"Camera", desc:"Background blur strength.", suggestions:["shallow","medium","deep"] },
      "lighting.type": { label:"Lighting type", category:"Lighting", desc:"Lighting setup.", suggestions:["studio softbox","natural daylight","rim light","cinematic lighting"] },
      "lighting.direction": { label:"Direction", category:"Lighting", desc:"Main light direction.", suggestions:["front","side","back","top"] },
      "background.location_type": { label:"Location type", category:"Background", desc:"High-level setting type.", suggestions:["studio","indoor","outdoor"] },
      "background.scene": { label:"Scene", category:"Background", desc:"Scene description.", suggestions:["minimal seamless backdrop","clean street background, minimal distractions","modern interior, minimal clutter"] },
      "style.genre": { label:"Genre", category:"Style", desc:"Aesthetic genre.", suggestions:["fashion","editorial","lifestyle","cinematic"] },
      "mood": { label:"Mood", category:"Mood", desc:"Emotional tone.", suggestions:["neutral","relaxed","calm, confident","dramatic","joyful"] },
      "constraints.must_include": { label:"Must include", category:"Constraints", desc:"Hard requirements. One item per line.", recommendation:"Include: no text, no logos, no watermarks, accurate hands, natural skin texture." },
      "constraints.avoid": { label:"Avoid", category:"Constraints", desc:"Negative constraints. One item per line.", recommendation:"Avoid: extra fingers, warped hands, deformed anatomy, blurred face, plastic skin, AI artifacts." },

      "references.images_included": { label:"Reference images included", category:"Identity & Consistency", desc:"Set true if you will upload reference images in the chat with this prompt pack.", suggestions:["true","false"] },
      "references.images": { label:"Reference images list", category:"Identity & Consistency", desc:"Optional. One item per line describing each reference image and its role (e.g., identity anchor, wardrobe, pose).", suggestions:["identity anchor: face", "style anchor: lighting", "pose anchor: stance"] },
      "references.notes": { label:"Reference notes", category:"Identity & Consistency", desc:"Optional notes on how to use the reference images.", suggestions:["Preserve identity; transfer lighting/style only", "Identity from ref#1, outfit from ref#2"] },

      "composition.crop_guards.hands": { label:"Crop guard: hands", category:"Composition", desc:"If true, add stronger hand visibility/quality guardrails.", suggestions:["true","false"] },
      "composition.crop_guards.feet": { label:"Crop guard: feet/shoes", category:"Composition", desc:"If true, add stronger feet/shoes visibility guardrails for full-body frames.", suggestions:["true","false"] },
      "composition.crop_guards.headroom": { label:"Headroom", category:"Composition", desc:"Control headroom in framing.", suggestions:["tight","normal","loose"] },

      "constraints.hard": { label:"Hard constraints (v1)", category:"Constraints", desc:"Alias of constraints.must_include.", suggestions:["no text","no logos","no watermarks","natural skin texture","accurate hands"] },
      "constraints.negative": { label:"Negative constraints (v1)", category:"Constraints", desc:"Alias of constraints.avoid.", suggestions:["extra fingers","warped hands","deformed anatomy","blurred face","plastic skin"] },
      "constraints.soft": { label:"Soft preferences (v1)", category:"Constraints", desc:"Non-hard preferences; lower priority than hard constraints.", suggestions:["subtle film grain","neutral background","editorial color grade"] },
      "meta.schema_id": { label:"Schema ID", category:"Output & Prompt", desc:"Schema identifier.", suggestions:[SCHEMA_ID_V1] }
    };

    const CATEGORY_ORDER = [
      "Output & Prompt","Composition","Subject","Identity & Consistency","Clothing","Accessories","Lighting","Background","Camera","Style","Mood","Constraints",
      "Ultra Elite: System","Ultra Elite: Environment","Ultra Elite: Rendering","Ultra Elite: Color Pipeline"
    ];

    const COMMON_FIELDS = [
      "output_specs.aspect_ratio",
      "composition.body_visibility",
      "composition.framing",
      "composition.orientation",
      "composition.crop_guards.hands",
      "composition.crop_guards.feet",
      "subject.gender",
      "subject.age",
      "subject.ethnicity",
      "clothing.top",
      "clothing.bottom",
      "camera.focal_length",
      "camera.depth_of_field",
      "lighting.type",
      "lighting.direction",
      "background.location_type",
      "background.scene",
      "style.genre",
      "mood",
      "references.images",
      "references.notes",
      "constraints.must_include",
      "constraints.avoid"
    ];

    function listLeafPaths(obj, prefix=""){
      const out = [];
      if (!obj || typeof obj !== "object") return out;
      for (const k of Object.keys(obj)){
        const p = prefix ? `${prefix}.${k}` : k;
        const v = obj[k];
        if (Array.isArray(v)) out.push(p);
        else if (v && typeof v === "object") out.push(...listLeafPaths(v, p));
        else out.push(p);
      }
      return out;
    }

    function ensureMetaForAllLeafPaths(root){
      const leaves = listLeafPaths(root);
      for (const p of leaves){
        if (p === "prompt_output.master_prompt") continue;
        if (!FIELD_META[p]){
          const top = p.split(".")[0];
          const map = {
            meta:"Output & Prompt", prompt_profile:"Output & Prompt", output_specs:"Output & Prompt", prompt_output:"Output & Prompt",
            composition:"Composition", subject:"Subject", identity:"Identity & Consistency", clothing:"Clothing", accessories:"Accessories",
            lighting:"Lighting", background:"Background", camera:"Camera", style:"Style", mood:"Mood", constraints:"Constraints",
            system_profile:"Ultra Elite: System", environment:"Ultra Elite: Environment", rendering:"Ultra Elite: Rendering", color_pipeline:"Ultra Elite: Color Pipeline"
          };
          FIELD_META[p] = { label: p, category: map[top] || "Output & Prompt", desc: "Advanced field. Use when you need fine-grained control.", suggestions:["(blank)"] };
        }
      }
    }

/* ---------- Schema path registry (union of templates) ---------- */
const SCHEMA_PATHS_BY_TEMPLATE = {};
let ALL_SCHEMA_PATHS = [];
const FIELD_TYPES = {}; // path -> "string"|"array"|"boolean"|"number"|"object"

function inferSchemaRegistry(){
  const union = new Set();
  Object.keys(TEMPLATE_BASES).forEach(tname=>{
    const paths = listLeafPaths(TEMPLATE_BASES[tname]).filter(p => p !== "prompt_output.master_prompt");
    SCHEMA_PATHS_BY_TEMPLATE[tname] = paths.slice();
    paths.forEach(p=> union.add(p));

    // infer type from template values
    paths.forEach(p=>{
      const v = getByPath(TEMPLATE_BASES[tname], p);
      let ty = Array.isArray(v) ? "array" : (typeof v);
      if (v === null || v === undefined) ty = FIELD_TYPES[p] || "string";
      if (ty === "object") ty = "object";
      FIELD_TYPES[p] = FIELD_TYPES[p] || ty;
    });
  });

  // Ensure compiler-owned fields exist in the registry
  ["prompt_output.user_prefix","prompt_output.negative_prompt","prompt_output.directive"].forEach(p=> union.add(p));
  union.add("meta.run_id");
  union.add("meta.doc_hash");
  union.add("meta.prompt_pack_hash");

  // v1 additions (references, constraint aliases, crop guards)
  [
    "references.images_included","references.images","references.notes",
    "constraints.hard","constraints.soft","constraints.negative",
    "composition.crop_guards.hands","composition.crop_guards.feet","composition.crop_guards.headroom",
    "meta.schema_id"
  ].forEach(p=> union.add(p));

  // Explicit v1 typing (templates might omit these)
  FIELD_TYPES["references.images_included"] = "boolean";
  FIELD_TYPES["references.images"] = "array";
  FIELD_TYPES["references.notes"] = "string";
  FIELD_TYPES["constraints.hard"] = "array";
  FIELD_TYPES["constraints.soft"] = "array";
  FIELD_TYPES["constraints.negative"] = "array";
  FIELD_TYPES["composition.crop_guards.hands"] = "boolean";
  FIELD_TYPES["composition.crop_guards.feet"] = "boolean";
  FIELD_TYPES["composition.crop_guards.headroom"] = "string";
  FIELD_TYPES["meta.schema_id"] = "string";
  ALL_SCHEMA_PATHS = [...union];

  // backfill FIELD_META for any new fields (so expert mode can render them)
  ALL_SCHEMA_PATHS.forEach(p=>{
    if (!FIELD_META[p]){
      const top = p.split(".")[0];
      const map = {
        meta:"Output & Prompt", prompt_profile:"Output & Prompt", output_specs:"Output & Prompt", prompt_output:"Output & Prompt",
        composition:"Composition", subject:"Subject", identity:"Identity & Consistency", clothing:"Clothing", accessories:"Accessories",
        lighting:"Lighting", background:"Background", camera:"Camera", style:"Style", mood:"Mood", constraints:"Constraints",
        system_profile:"Ultra Elite: System", environment:"Ultra Elite: Environment", rendering:"Ultra Elite: Rendering", color_pipeline:"Ultra Elite: Color Pipeline"
      };
      FIELD_META[p] = { label: p, category: map[top] || "Output & Prompt", desc: "Advanced field. Use when you need fine-grained control.", suggestions:["(blank)"] };
    }
    if (!FIELD_META[p].type && FIELD_TYPES[p]) FIELD_META[p].type = FIELD_TYPES[p];
  });
}


function buildAllowedPrefixSet(paths){
  const set = new Set();
  set.add(""); // root
  (paths||[]).forEach(p=>{
    const parts = String(p).split(".");
    let cur = "";
    for (const part of parts){
      cur = cur ? `${cur}.${part}` : part;
      set.add(cur);
    }
  });
  return set;
}

function quarantineUnknownFields(doc, schemaPaths){
  const allowedPrefixes = buildAllowedPrefixSet(schemaPaths);
  const quarantine = {};
  const walk = (obj, prefix)=>{
    if (!isPlainObject(obj)) return;
    for (const k of Object.keys(obj)){
      if (BLOCKED_KEYS.has(k)){ delete obj[k]; continue; }
      const p = prefix ? `${prefix}.${k}` : k;
      if (!allowedPrefixes.has(p)){
        quarantine[p] = obj[k];
        delete obj[k];
        continue;
      }
      const v = obj[k];
      if (isPlainObject(v)) walk(v, p);
      // arrays/primitives are leafs; OK if prefix allowed
    }
  };
  walk(doc, "");
  if (Object.keys(quarantine).length){
    doc.meta = doc.meta || {};
    doc.meta._quarantine = quarantine;
  }
  return quarantine;
}

function coerceTypesInPlace(doc){
  const issues = [];
  // Coerce known leaf paths where type is known
  const paths = ALL_SCHEMA_PATHS || [];
  paths.forEach(p=>{
    const expected = FIELD_TYPES[p] || FIELD_META[p]?.type;
    if (!expected) return;
    const cur = getByPath(doc, p);
    if (cur === undefined) return;

    if (expected === "array" && typeof cur === "string"){
      setByPath(doc, p, parseFreeformTokens(cur));
      issues.push(`Coerced ${p} string -> array`);
    }
    if (expected === "boolean" && typeof cur === "string"){
      const s = cur.toLowerCase().trim();
      if (s === "true" || s === "false"){
        setByPath(doc, p, s === "true");
        issues.push(`Coerced ${p} string -> boolean`);
      }
    }
  });
  return issues;
}

/* ---------- v1 defaults + compatibility shims ---------- */
function ensureDefaultsForV1(doc){
  if (!doc || typeof doc !== "object") return doc;

  // meta
  doc.meta = doc.meta || {};
  if (!doc.meta.schema_id) doc.meta.schema_id = SCHEMA_ID_V1;

  // references
  if (!isPlainObject(doc.references)) doc.references = {};
  if (doc.references.images_included === undefined) doc.references.images_included = false;
  if (typeof doc.references.images_included === "string") doc.references.images_included = (doc.references.images_included.toLowerCase().trim() === "true");
  if (doc.references.images === undefined) doc.references.images = [];
  if (typeof doc.references.images === "string") doc.references.images = parseFreeformTokens(doc.references.images);
  if (!Array.isArray(doc.references.images)) doc.references.images = [];
  if (doc.references.notes === undefined) doc.references.notes = "";

  // constraints v1 aliases
  if (!isPlainObject(doc.constraints)) doc.constraints = {};
  if (!Array.isArray(doc.constraints.must_include) && Array.isArray(doc.constraints.hard)) doc.constraints.must_include = doc.constraints.hard.slice();
  if (!Array.isArray(doc.constraints.avoid) && Array.isArray(doc.constraints.negative)) doc.constraints.avoid = doc.constraints.negative.slice();
  if (!Array.isArray(doc.constraints.hard)) doc.constraints.hard = Array.isArray(doc.constraints.must_include) ? doc.constraints.must_include.slice() : [];
  if (!Array.isArray(doc.constraints.negative)) doc.constraints.negative = Array.isArray(doc.constraints.avoid) ? doc.constraints.avoid.slice() : [];
  if (!Array.isArray(doc.constraints.soft)) doc.constraints.soft = [];

  // crop guards
  if (!isPlainObject(doc.composition)) doc.composition = {};
  if (!isPlainObject(doc.composition.crop_guards)) doc.composition.crop_guards = {};
  if (doc.composition.crop_guards.hands === undefined) doc.composition.crop_guards.hands = false;
  if (doc.composition.crop_guards.feet === undefined) doc.composition.crop_guards.feet = false;
  if (!doc.composition.crop_guards.headroom) doc.composition.crop_guards.headroom = "normal";

  // prompt_output
  if (!isPlainObject(doc.prompt_output)) doc.prompt_output = {};
  if (doc.prompt_output.user_prefix === undefined) doc.prompt_output.user_prefix = "";
  if (doc.prompt_output.negative_prompt === undefined) doc.prompt_output.negative_prompt = "";
  if (doc.prompt_output.directive === undefined) doc.prompt_output.directive = "";

  return doc;
}

    /* ---------- Preset storage ---------- */
    function loadUserPresets(){
  try{
    let raw = localStorage.getItem(LS_KEY);
    if (!raw){
      // v1.0.x migration
      raw = localStorage.getItem("promptforge_ris_user_presets_v100");
      if (!raw){
        // v0.8.x migration
        raw = localStorage.getItem("promptforge_ris_user_presets_v080");
        if (!raw){
          // v0.7.x migration
          raw = localStorage.getItem("promptforge_ris_user_presets_v070");
        }
      }
      if (raw) localStorage.setItem(LS_KEY, raw);
    }
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : [];
  }catch{ return []; }
}
    function saveUserPresets(p){ localStorage.setItem(LS_KEY, JSON.stringify(p)); }

/* ---------- Run history (localStorage) ---------- */
function loadRuns(){
  try{
    let raw = localStorage.getItem(LS_RUNS);
    if (!raw){
      // v1.0.x migration
      raw = localStorage.getItem("promptforge_ris_runs_v100");
      if (!raw){
        // v0.8.x migration
        raw = localStorage.getItem("promptforge_ris_runs_v080");
        if (!raw){
          // v0.7.x migration (if present)
          raw = localStorage.getItem("promptforge_ris_runs_v070");
        }
      }
      if (raw) localStorage.setItem(LS_RUNS, raw);
    }
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : [];
  }catch{ return []; }
}
function saveRuns(runs){
  localStorage.setItem(LS_RUNS, JSON.stringify(runs));
}

function addRun(record){
  const runs = loadRuns();
  runs.unshift(record);
  // cap
  while (runs.length > 30) runs.pop();
  saveRuns(runs);
  renderRunsDrawer();
}

function renderRunsDrawer(){
  const el = $("runsBody");
  if (!el) return;
  const runs = loadRuns();
  if (!runs.length){
    el.innerHTML = `<div class="help-inline">No saved runs yet.</div>`;
    return;
  }
  el.innerHTML = runs.map(r=>{
    const ts = new Date(r.ts || Date.now()).toLocaleString();
    const name = escapeHtml(r.name || "");
    const tpl = escapeHtml(r.template || "");
    const rid = escapeHtml(r.run_id || "");
    const hash = escapeHtml(r.doc_hash || "");
    return `
      <div class="card" style="padding:10px; margin:10px 0;">
        <div class="mini">${ts}</div>
        <div><b>${name || "(no name)"}</b> <span class="chip">${tpl || "template?"}</span></div>
        <div class="mini">Run-ID: ${rid} • Doc: ${hash}</div>
        <div class="btnrow" style="margin-top:8px">
          <button class="btn" data-act="load" data-id="${escapeHtml(r.id)}">Load</button>
          <button class="btn" data-act="copy" data-id="${escapeHtml(r.id)}">Copy Pack</button>
          <button class="btn" data-act="copyjson" data-id="${escapeHtml(r.id)}">Copy JSON</button>
        </div>
      </div>
    `;
  }).join("");

  el.querySelectorAll("button[data-act]").forEach(btn=>{
    btn.onclick = async ()=>{
      const id = btn.getAttribute("data-id");
      const act = btn.getAttribute("data-act");
      const runs = loadRuns();
      const r = runs.find(x=>x.id===id);
      if (!r) return;

      if (act === "load"){
        if (r.template && TEMPLATE_BASES[r.template]){
          currentTemplateName = r.template;
          baseData = deepClone(TEMPLATE_BASES[r.template]);
          $("templateSelect").value = r.template;
          $("templateDesc").textContent = TEMPLATE_INFO[r.template] || "";
          }
        currentData = deepClone(r.doc || {});
        renderStep2(); if ($("card3")) renderStep3(); if ($("card4")) renderStep4();
        refreshOutput();
        saveState();
        toast("Loaded run", "ok", r.run_id || "run");
        return;
      }

      if (act === "copy"){
        const ok = await copyToClipboard(String(r.prompt_pack || ""));
        ok ? toast("Copied prompt pack", "ok", "Runs") : toast("Copy failed", "err", "Clipboard");
        return;
      }

      if (act === "copyjson"){
        const ok = await copyToClipboard(JSON.stringify(r.doc || {}, null, 2));
        ok ? toast("Copied JSON", "ok", "Runs") : toast("Copy failed", "err", "Clipboard");
        return;
      }
    };
  });
}


/* ---------- Compiler (Prompt Pack + JSON Patch) ---------- */
function isUltraDoc(data){
  return !!(data?.system_profile || data?.environment || data?.rendering || data?.color_pipeline || data?.subject?.identity);
}

function parseFreeformTokens(text){
  if (!text) return [];
  return String(text)
    .split(/[\n,]+/g)
    .map(s=>s.trim())
    .filter(Boolean);
}

function buildNegativeTokens(doc, mustIncludeArr, avoidArr){
  const must = Array.isArray(mustIncludeArr) ? mustIncludeArr : [];
  const avoid = Array.isArray(avoidArr) ? avoidArr : [];
  const fromMust = must.filter(x=>/^\s*no\s+/i.test(String(x||""))).map(x=>String(x).trim());
  const extra = parseFreeformTokens(doc?.prompt_output?.negative_prompt || "");
  const baseline = [
    "no text","no logos","no watermark","no watermarks","no signature","no captions","no subtitles"
  ];
  return uniqNorm([...baseline, ...fromMust, ...avoid, ...extra]);
}

function validateDocV1(doc){
  inferSchemaRegistry();
  const errors = [];
  const warnings = [];

  // Required-ish core fields
  [
    "output_specs.aspect_ratio",
    "composition.body_visibility",
    "composition.framing"
  ].forEach(p=>{
    const v = getByPath(doc, p);
    if (v === undefined || v === null || v === "" || (Array.isArray(v) && v.length===0)) errors.push(`Missing required field: ${p}`);
  });

  // Constraints present (either alias)
  const hard = uniq([...(doc?.constraints?.must_include||[]), ...(doc?.constraints?.hard||[])]);
  if (!hard.length) warnings.push("No hard constraints found (constraints.must_include / constraints.hard). Expect lower controllability.");

  // Type checks for present fields
  const present = listLeafPaths(doc).filter(p => p !== "prompt_output.master_prompt");
  for (const p of present){
    if (!ALL_SCHEMA_PATHS.includes(p)){
      warnings.push(`Unknown field present: ${p}`);
      continue;
    }
    const expected = FIELD_TYPES[p] || "string";
    const v = getByPath(doc, p);
    if (expected === "array" && !Array.isArray(v)) errors.push(`Type error at ${p}: expected array`);
    else if (expected === "boolean" && typeof v !== "boolean") errors.push(`Type error at ${p}: expected boolean`);
    else if (expected === "number" && typeof v !== "number") warnings.push(`Type warning at ${p}: expected number`);
    else if (expected === "string" && typeof v !== "string") warnings.push(`Type warning at ${p}: expected string`);
  }

  // Soft enum checks for a few high-value controls
  const enumFields = [
    "output_specs.aspect_ratio",
    "composition.body_visibility",
    "composition.orientation",
    "lighting.direction",
    "background.location_type",
    "camera.depth_of_field",
    "composition.crop_guards.headroom"
  ];
  for (const p of enumFields){
    const v = getByPath(doc, p);
    if (!v) continue;
    const sug = (FIELD_META[p] && Array.isArray(FIELD_META[p].suggestions)) ? FIELD_META[p].suggestions : null;
    if (sug && sug.length && !sug.includes(String(v)) && !sug.includes("(omit)")) warnings.push(`Nonstandard value for ${p}: “${v}”`);
  }

  // References toggle coherence
  if (doc?.references?.images_included){
    const list = Array.isArray(doc.references.images) ? doc.references.images : [];
    const notes = String(doc.references.notes || "").trim();
    if (!list.length && !notes) warnings.push("Reference images included is ON but references.images / references.notes are empty.");
  }

  return { errors, warnings };
}

function compilePromptPack(doc, ctx={}){
  const lint = { errors:[], warnings:[], notes:[] };
  ensureDefaultsForV1(doc);

  if (strictValidation){
    const v = validateDocV1(doc);
    lint.errors.push(...v.errors);
    lint.warnings.push(...v.warnings);
  }

  const name = String(ctx.chatName ?? doc?.meta?.chat_name ?? "").trim();
  const purposeText = String(ctx.purpose ?? doc?.meta?.purpose ?? "").trim();
  const templateLabel = String(ctx.templateName ?? doc?.meta?.template ?? currentTemplateName ?? "").trim();
  const schemaId = String(doc?.meta?.schema_id || SCHEMA_ID_V1);
  const runId = String(doc?.meta?.run_id ?? "").trim() || uuidv4();

  const isUltra = isUltraDoc(doc);
  const ar = doc?.output_specs?.aspect_ratio || doc?.render?.output?.aspect_ratio || "4:5";
  const mode = doc?.prompt_profile?.mode || "photoreal";

  const sec = {
    subject: [],
    identity: [],
    clothing: [],
    composition: [],
    background: [],
    lighting: [],
    camera: [],
    style: [],
    quality: []
  };

  // Core controls
  sec.quality.push(`${mode} image`);
  if (ar) sec.quality.push(`aspect ratio ${ar}`);

  // Subject + identity
  if (isUltra){
    const id = doc?.subject?.identity || {};
    if (id.core_description) sec.subject.push(id.core_description);
    const fs = id.facial_structure || {};
    const fsBits = ["face_shape","jawline","cheekbones","nose_shape","eye_shape","eyebrow_shape"].map(k=>fs[k]).filter(Boolean);
    if (fsBits.length) sec.identity.push(`facial structure: ${fsBits.join(", ")}`);
    const sk = id.skin || {};
    const skinBits = [sk.texture, sk.pores, sk.imperfections, sk.subsurface_scattering].filter(Boolean);
    if (skinBits.length) sec.identity.push(`skin: ${skinBits.join(", ")}`);
    const hr = id.hair || {};
    const hairBits = [hr.color, hr.style, hr.physics, hr.strand_detail, hr.density].filter(Boolean);
    if (hairBits.length) sec.identity.push(`hair: ${hairBits.join(", ")}`);
    if (id.identity_lock) sec.identity.push("strict identity lock");
  } else {
    const s = doc?.subject || {};
    const demographics = [s.gender, s.age, (s.ethnicity && s.ethnicity !== "unspecified") ? s.ethnicity : ""].filter(Boolean).join(", ");
    if (demographics) sec.subject.push(demographics);
    if (s.skin?.details) sec.identity.push(s.skin.details);
    if (s.face?.features) sec.identity.push(s.face.features);
    if (s.hair?.details) sec.identity.push(s.hair.details);

    const id = doc?.identity || {};
    if (id.identity_strength) sec.identity.push(`identity lock: ${id.identity_strength}`);
    if (id.distinctive_features) sec.identity.push(id.distinctive_features);
    if (Array.isArray(id.do_not_change) && id.do_not_change.length) sec.identity.push(`do not change: ${id.do_not_change.join(", ")}`);
  }

  // Clothing
  if (isUltra){
    const cl = doc?.subject?.clothing || {};
    if (Array.isArray(cl.garments) && cl.garments.length) sec.clothing.push(`garments: ${cl.garments.join(", ")}`);
    if (Array.isArray(cl.materials) && cl.materials.length) sec.clothing.push(`materials: ${cl.materials.join(", ")}`);
    if (cl.fabric_behavior) sec.clothing.push(cl.fabric_behavior);
    if (cl.micro_detail) sec.clothing.push(cl.micro_detail);
  } else {
    const c = doc?.clothing || {};
    const garments = [c.top, c.bottom, (c.outerwear && c.outerwear !== "none") ? c.outerwear : "", (c.dress && c.dress !== "none") ? c.dress : "", (c.footwear && c.footwear !== "none") ? c.footwear : ""].filter(Boolean);
    if (garments.length) sec.clothing.push(`garments: ${garments.join(", ")}`);
    if (Array.isArray(c.materials) && c.materials.length) sec.clothing.push(`materials: ${c.materials.join(", ")}`);
    if (c.notes) sec.clothing.push(c.notes);
  }

  // Composition
  const comp = doc?.composition || {};
  if (isUltra){
    if (comp.framing) sec.composition.push(comp.framing);
    if (comp.rule_of_thirds) sec.composition.push(comp.rule_of_thirds);
    if (comp.spatial_depth) sec.composition.push(comp.spatial_depth);
    if (comp.visual_weight) sec.composition.push(comp.visual_weight);
  } else {
    const line1 = [comp.shot_type, comp.body_visibility, comp.framing].filter(Boolean).join(", ");
    const line2 = [comp.orientation, comp.subject_position, comp.camera_height, comp.camera_distance, comp.perspective].filter(Boolean).join(", ");
    if (line1) sec.composition.push(line1);
    if (line2) sec.composition.push(line2);
    if (comp.background_blur_intent) sec.composition.push(`background blur: ${comp.background_blur_intent}`);
  }

  const cg = comp.crop_guards || {};
  if (cg.headroom) sec.composition.push(`headroom: ${cg.headroom}`);

  // Environment / background
  if (isUltra){
    const env = doc?.environment || {};
    const envBits = [env.location, env.architecture].filter(Boolean).join(", ");
    if (envBits) sec.background.push(envBits);
    if (env.atmosphere) sec.background.push(env.atmosphere);
    if (env.physics_interaction) sec.background.push(env.physics_interaction);
  } else {
    const bg = doc?.background || {};
    const bgBits = [bg.location_type, bg.scene].filter(Boolean).join(", ");
    if (bgBits) sec.background.push(bgBits);
    if (bg.palette) sec.background.push(`palette: ${bg.palette}`);
    if (bg.notes) sec.background.push(bg.notes);
  }

  // Lighting
  const light = doc?.lighting || {};
  if (isUltra){
    if (Array.isArray(light.sources) && light.sources.length) sec.lighting.push(`sources: ${light.sources.join(", ")}`);
    if (light.global_illumination) sec.lighting.push(light.global_illumination);
    if (light.shadow_behavior) sec.lighting.push(light.shadow_behavior);
    if (light.reflections) sec.lighting.push(light.reflections);
    if (light.volumetrics) sec.lighting.push(light.volumetrics);
  } else {
    const lBits = [light.type, light.direction, light.quality, light.tone].filter(Boolean).join(", ");
    if (lBits) sec.lighting.push(lBits);
    if (light.notes) sec.lighting.push(light.notes);
  }

  // Camera + rendering/style
  const cam = doc?.camera || {};
  if (isUltra){
    const camBits = [cam.model_simulation, cam.lens_model, cam.sensor_size].filter(Boolean).join(", ");
    if (camBits) sec.camera.push(camBits);
    if (cam.focus_behavior) sec.camera.push(cam.focus_behavior);
    if (cam.optical_aberrations) sec.camera.push(cam.optical_aberrations);
    if (cam.exposure_pipeline) sec.camera.push(cam.exposure_pipeline);

    const r = doc?.rendering || {};
    const rBits = [r.realism_level, r.material_model, r.texture_resolution].filter(Boolean).join(", ");
    if (rBits) sec.style.push(rBits);
    if (r.noise_profile) sec.style.push(r.noise_profile);
    if (r.ray_tracing) sec.style.push(r.ray_tracing);
    if (r.motion_blur) sec.style.push(r.motion_blur);

    const cp = doc?.color_pipeline || {};
    const cpBits = [cp.tone_mapping, cp.grading_profile, cp.dynamic_range].filter(Boolean).join(", ");
    if (cpBits) sec.style.push(cpBits);
  } else {
    const camBits = [cam.photo_style, cam.focal_length, cam.depth_of_field, cam.exposure, cam.grain].filter(Boolean).join(", ");
    if (camBits) sec.camera.push(camBits);

    const st = doc?.style || {};
    const stBits = [st.genre, st.strength, st.realism_strength, st.color_grading, st.contrast, st.sharpness].filter(Boolean).join(", ");
    if (stBits) sec.style.push(stBits);
  }

  if (doc?.mood) sec.style.push(`mood: ${doc.mood}`);

  // Constraints + negatives (v1 aliases)
  const hard = uniq([...(doc?.constraints?.must_include||[]), ...(doc?.constraints?.hard||[])]);
  const avoid = uniq([...(doc?.constraints?.avoid||[]), ...(doc?.constraints?.negative||[])]);
  const soft = Array.isArray(doc?.constraints?.soft) ? doc.constraints.soft : [];

  // Crop guard amplification
  if (cg.hands){
    ["include hands", "accurate hands and fingers", "no hand deformation"].forEach(t=>{ if (!hard.map(x=>String(x).toLowerCase()).includes(t.toLowerCase())) hard.push(t); });
    ["extra fingers","warped hands","deformed hands"].forEach(t=>{ if (!avoid.map(x=>String(x).toLowerCase()).includes(t.toLowerCase())) avoid.push(t); });
  }
  if (cg.feet){
    ["include feet and shoes", "accurate feet"].forEach(t=>{ if (!hard.map(x=>String(x).toLowerCase()).includes(t.toLowerCase())) hard.push(t); });
    ["cut off shoes","missing feet"].forEach(t=>{ if (!avoid.map(x=>String(x).toLowerCase()).includes(t.toLowerCase())) avoid.push(t); });
  }

  const hardLower = hard.map(s=>String(s||"").toLowerCase());
  ["no text","no logos","no watermarks"].forEach(x=>{
    if (!hardLower.includes(x)) lint.warnings.push(`Hard constraints missing “${x}”`);
  });

  const avoidLower = avoid.map(s=>String(s||"").toLowerCase());
  ["extra fingers","warped hands","deformed anatomy"].forEach(x=>{
    if (!avoidLower.includes(x)) lint.notes.push(`Consider adding to constraints.avoid: “${x}”`);
  });

  const framing = String(doc?.composition?.framing || "").toLowerCase();
  const bv = String(doc?.composition?.body_visibility || "").toLowerCase();
  if (bv.includes("full") && !framing.includes("toe") && !framing.includes("feet") && !framing.includes("shoes")) lint.warnings.push("Full-body requested but framing doesn't mention feet/shoes.");
  if ((framing.includes("hands") || cg.hands) && !(avoidLower.includes("extra fingers") || avoidLower.includes("warped hands"))) lint.warnings.push("Hands are requested but negative constraints don't explicitly guard hands/fingers.");

  // Quality/guard section content
  if (hard.length) sec.quality.push(`hard constraints: ${hard.join(", ")}`);
  if (soft.length) sec.quality.push(`soft constraints: ${soft.join(", ")}`);

  const negative = buildNegativeTokens(doc, hard, avoid);

  // Sectioned prompt body (stable ordering)
  const promptLines = [];
  const emit = (title, arr)=>{
    const a = (arr || []).map(x=>String(x||"").trim()).filter(Boolean);
    if (!a.length) return;
    promptLines.push(`${title}:`);
    a.forEach(x=> promptLines.push(`- ${x}`));
    promptLines.push("");
  };

  emit("SUBJECT", sec.subject);
  emit("IDENTITY", sec.identity);
  emit("CLOTHING", sec.clothing);
  emit("COMPOSITION", sec.composition);
  emit("BACKGROUND", sec.background);
  emit("LIGHTING", sec.lighting);
  emit("CAMERA", sec.camera);
  emit("STYLE", sec.style);
  emit("QUALITY_GUARDS", sec.quality);

  const promptBody = promptLines.join("\n").trim();
  const positiveFlat = uniqNorm([promptBody.replace(/\n/g, " ")]).join(" ").replace(/\s+/g," ").trim();

  const directive = String(doc?.prompt_output?.directive || "").trim() || "Use the built-in image generator to create 1 image. Output ONLY the image. No explanations. No captions. No text/logos/watermarks.";

  const refsOn = !!doc?.references?.images_included;
  const refList = Array.isArray(doc?.references?.images) ? doc.references.images : [];
  const refNotes = String(doc?.references?.notes || "").trim();

  const docHash = fnv1a32(stableStringify(doc));
  const packHash = fnv1a32(promptBody + "||" + negative.join("|"));

  const packLines = [
    `[PROMPT_PACK • ${APP_NAME} ${APP_VERSION}]`,
    `Schema-ID: ${schemaId}`,
    `Name: ${name || "(none)"}`,
    `Purpose: ${purposeText || "(none)"}`,
    `Template: ${templateLabel || "(unknown)"}`,
    `Run-ID: ${runId}`,
    `Doc-Hash: ${docHash}`,
    `Prompt-Hash: ${packHash}`,
    "",
    "INSTRUCTIONS:",
    `- ${directive}`,
    ...(refsOn ? ["- Use the uploaded reference images as anchors. Preserve identity and key attributes."] : []),
    "",
    "PROMPT:",
    promptBody || "(empty)",
    "",
    "NEGATIVE:",
    negative.length ? negative.join(", ") : "(none)"
  ];

  if (refsOn || refList.length || refNotes){
    packLines.push("");
    packLines.push("REFERENCE_IMAGES:");
    if (refList.length) refList.forEach(x=> packLines.push(`- ${x}`));
    if (refNotes) packLines.push(`Notes: ${refNotes}`);
  }

  if (refsOn){
    packLines.push("");
    packLines.push("Reference images included");
  }

  const promptPack = packLines.join("\n");

  return {
    promptPack,
    positive: positiveFlat,
    negative,
    lint,
    manifest: { run_id: runId, doc_hash: docHash, prompt_pack_hash: packHash, aspect_ratio: ar, schema_id: schemaId }
  };
}

function computeJsonPatch(base, cur){
  // RFC6902-ish ops (add/replace/remove). Good-enough for reproducible overlays.
  const ops = [];
  const esc = (s)=>String(s).replace(/~/g,"~0").replace(/\//g,"~1");
  const walk = (b, c, p)=>{
    if (deepEqual(b, c)) return;

    const bObj = isPlainObject(b);
    const cObj = isPlainObject(c);

    if (Array.isArray(b) || Array.isArray(c)){
      ops.push({ op: (b === undefined) ? "add" : (c === undefined) ? "remove" : "replace", path: p || "/", value: c });
      return;
    }

    if (!bObj || !cObj){
      if (c === undefined) ops.push({ op:"remove", path: p || "/" });
      else ops.push({ op: (b === undefined) ? "add" : "replace", path: p || "/", value: c });
      return;
    }

    const keys = new Set([...Object.keys(b||{}), ...Object.keys(c||{})]);
    for (const k of Array.from(keys).sort()){
      if (BLOCKED_KEYS.has(k)) continue;
      const np = (p || "") + "/" + esc(k);
      if (!(k in c)){
        ops.push({ op:"remove", path: np });
        continue;
      }
      if (!(k in b)){
        ops.push({ op:"add", path: np, value: c[k] });
        continue;
      }
      walk(b[k], c[k], np);
    }
  };
  walk(base, cur, "");
  return ops;
}

/* ---------- JSON Schema export (draft 2020-12, pragmatic subset) ---------- */
function generateJsonSchema(templateName){
  inferSchemaRegistry();
  const tpl = TEMPLATE_BASES[templateName] ? deepClone(TEMPLATE_BASES[templateName]) : {};
  ensureDefaultsForV1(tpl);

  const root = {
    $schema: SCHEMA_DRAFT,
    $id: SCHEMA_ID_V1,
    title: "PromptForge RIS Person Shot Schema",
    type: "object",
    additionalProperties: false,
    properties: {},
    required: ["meta", "prompt_profile", "output_specs", "composition", "constraints", "prompt_output"]
  };

  const setLeaf = (objSchema, parts, leafSchema)=>{
    let cur = objSchema;
    for (let i=0;i<parts.length;i++){
      const k = parts[i];
      cur.properties = cur.properties || {};
      if (i === parts.length-1){
        cur.properties[k] = leafSchema;
        return;
      }
      if (!cur.properties[k]){
        cur.properties[k] = { type:"object", additionalProperties:false, properties:{} };
      }
      cur = cur.properties[k];
    }
  };

  const leafSchemaFor = (path)=>{
    const t = FIELD_TYPES[path] || "string";
    const meta = FIELD_META[path] || {};
    const desc = meta.desc || meta.recommendation || "";
    const sug = Array.isArray(meta.suggestions) ? meta.suggestions : null;
    const baseVal = getByPath(tpl, path);

    let s = { type: (t === "array") ? "array" : (t === "boolean") ? "boolean" : (t === "number") ? "number" : (t === "object") ? "object" : "string" };

    if (desc) s.description = desc;
    if (sug && sug.length) s.examples = sug.filter(x=>x && x !== "(omit)").slice(0, 10);

    if (path.startsWith("meta.") && ["meta.run_id","meta.doc_hash","meta.prompt_pack_hash"].includes(path)) s.readOnly = true;
    if (path === "meta.schema_id") s.readOnly = true;

    if (s.type === "array"){
      s.items = { type:"string" };
      if (Array.isArray(baseVal)) s.default = baseVal;
    } else if (s.type === "boolean"){
      if (typeof baseVal === "boolean") s.default = baseVal;
    } else if (s.type === "number"){
      if (typeof baseVal === "number") s.default = baseVal;
    } else if (s.type === "string"){
      if (typeof baseVal === "string") s.default = baseVal;
    } else if (s.type === "object"){
      s.additionalProperties = true;
    }

    return s;
  };

  // build properties from the registry
  ALL_SCHEMA_PATHS.slice().sort().forEach(p=>{
    const parts = p.split(".");
    setLeaf(root, parts, leafSchemaFor(p));
  });

  // a few friendly top-level annotations
  root.$comment = `Generated by ${APP_NAME} ${APP_VERSION} on ${new Date().toISOString()}`;
  return root;
}

function renderSchemaPathList(){
  try{
    inferSchemaRegistry();
    const dl = $("schemaPathList");
    if (!dl) return;
    dl.innerHTML = ALL_SCHEMA_PATHS.slice().sort().map(p=>`<option value="${escapeHtml(p)}"></option>`).join("");
  }catch(_){ /* noop */ }
}

function exportSchemaText(){
  return JSON.stringify(generateJsonSchema(currentTemplateName), null, 2);
}

async function copySchemaToClipboard(){
  try{
    const txt = exportSchemaText();
    await navigator.clipboard.writeText(txt);
    toast("Schema copied", "ok", "Schema");
  }catch(_){
    toast("Copy failed", "err", "Schema");
  }
}

function downloadSchemaFile(){
  try{
    const txt = exportSchemaText();
    const blob = new Blob([txt], {type:"application/schema+json"});
    const a=document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `promptforge_ris_schema_${Date.now()}.schema.json`;
    a.click();
    URL.revokeObjectURL(a.href);
    toast("Schema saved", "ok", "Schema");
  }catch(_){
    toast("Save failed", "err", "Schema");
  }
}

function validateNow(){
  refreshOutput();
  const l = lastDerived?.lint || {errors:[],warnings:[]};
  const e = (l.errors||[]).length;
  const w = (l.warnings||[]).length;
  if (e) toast(`${e} error(s), ${w} warning(s)`, "err", "Validation");
  else if (w) toast(`${w} warning(s)`, "warn", "Validation");
  else toast("No issues detected", "ok", "Validation");
}

// Macro helpers keep constraint aliases in sync
function addHard(token){
  ensureDefaultsForV1(currentData);
  ensureArrayContains(currentData, "constraints.must_include", token);
  ensureArrayContains(currentData, "constraints.hard", token);
}
function addNeg(token){
  ensureDefaultsForV1(currentData);
  ensureArrayContains(currentData, "constraints.avoid", token);
  ensureArrayContains(currentData, "constraints.negative", token);
}

function macroHandsSafe(){
  setByPath(currentData, "composition.crop_guards.hands", true);
  ["include hands", "accurate hands and fingers", "no hand deformation"].forEach(addHard);
  ["extra fingers","warped hands","deformed hands"].forEach(addNeg);
  toast("Applied Hands-safe", "ok", "Macro");
  renderStep2(); if ($("card3")) renderStep3(); if ($("card4")) renderStep4(); refreshOutput(); saveState();
}

function macroNoTextStrict(){
  ["no text","no logos","no watermarks","no signature","no captions"].forEach(addHard);
  ["text","watermark","logo","signature"].forEach(addNeg);
  toast("Applied No-text strict", "ok", "Macro");
  renderStep2(); if ($("card3")) renderStep3(); if ($("card4")) renderStep4(); refreshOutput(); saveState();
}

function macroSkinRealism(){
  ["natural skin texture","visible pores","subsurface scattering","realistic micro-contrast","accurate skin shading"].forEach(addHard);
  ["plastic skin","over-smoothed skin","airbrushed skin","waxy skin"].forEach(addNeg);
  toast("Applied Skin realism", "ok", "Macro");
  renderStep2(); if ($("card3")) renderStep3(); if ($("card4")) renderStep4(); refreshOutput(); saveState();
}

function macroIdentityLock(){
  setByPath(currentData, "identity.identity_strength", "strict");
  addHard("strict identity lock");
  toast("Applied Identity lock", "ok", "Macro");
  renderStep2(); if ($("card3")) renderStep3(); if ($("card4")) renderStep4(); refreshOutput(); saveState();
}

function coerceSweepValue(path, raw){
  const t = FIELD_TYPES[path] || "string";
  if (t === "array") return parseFreeformTokens(raw);
  if (t === "boolean") return /^(true|1|yes|on)$/i.test(String(raw).trim());
  if (t === "number"){
    const n = Number(raw);
    return Number.isFinite(n) ? n : raw;
  }
  return String(raw).trim();
}

function renderSweepResults(items){
  const wrap = $("sweepResults");
  if (!wrap) return;
  if (!items || !items.length){ wrap.innerHTML = "<div class=\"help-inline\">No sweep results yet.</div>"; return; }
  wrap.innerHTML = items.map((it, idx)=>{
    const title = escapeHtml(it.title);
    const hash = escapeHtml(it.manifest?.prompt_pack_hash || "");
    return `
      <div class="card" style="margin-top:10px;">
        <div class="row" style="justify-content:space-between; align-items:center;">
          <div>
            <div><b>${title}</b></div>
            <div class="help-inline">Prompt-Hash: ${hash}</div>
          </div>
          <div class="btnrow">
            <button class="btn" data-sweep-copy="${idx}">Copy Prompt</button>
            <button class="btn" data-sweep-json="${idx}">Copy JSON</button>
          </div>
        </div>
      </div>
    `;
  }).join("");

  // bind copy buttons
  wrap.querySelectorAll("button[data-sweep-copy]").forEach(btn=>{
    btn.onclick = async ()=>{
      const i = Number(btn.getAttribute("data-sweep-copy"));
      const txt = items[i]?.promptPack || "";
      try{ await navigator.clipboard.writeText(txt); toast("Copied", "ok", "Sweep"); }catch(_){ toast("Copy failed", "err", "Sweep"); }
    };
  });
  wrap.querySelectorAll("button[data-sweep-json]").forEach(btn=>{
    btn.onclick = async ()=>{
      const i = Number(btn.getAttribute("data-sweep-json"));
      const txt = JSON.stringify(items[i]?.doc || {}, null, 2);
      try{ await navigator.clipboard.writeText(txt); toast("Copied", "ok", "Sweep"); }catch(_){ toast("Copy failed", "err", "Sweep"); }
    };
  });
}

function runSweep(){
  inferSchemaRegistry();
  const path = String($("sweepPath")?.value || "").trim();
  const vals = parseFreeformTokens($("sweepValues")?.value || "");
  if (!path){ toast("Select a field path", "warn", "Sweep"); return; }
  if (!vals.length){ toast("Add at least one value", "warn", "Sweep"); return; }
  if (!ALL_SCHEMA_PATHS.includes(path)) toast("Path not in schema registry (will still attempt)", "warn", "Sweep");

  const results = [];
  for (const v of vals){
    const variant = deepClone(currentData);
    ensureDefaultsForV1(variant);
    setByPath(variant, path, coerceSweepValue(path, v));

    // compile without mutating global state
    const doc = stripEmpties(variant) || {};
    doc.meta = doc.meta || {};
    doc.meta.app_name = APP_NAME;
    doc.meta.schema_version = APP_VERSION;
    doc.meta.schema_id = SCHEMA_ID_V1;
    doc.meta.template = currentTemplateName;
    doc.meta.generated_at = new Date().toISOString();
    const compiled = compilePromptPack(doc, { chatName, purpose, templateName: currentTemplateName });
    results.push({
      title: `${path} = ${v}`,
      promptPack: compiled.promptPack,
      manifest: compiled.manifest,
      doc
    });
  }

  window.__sweepCache = results;
  renderSweepResults(results);
  toast(`Generated ${results.length} variant(s)`, "ok", "Sweep");
}

function clearSweep(){
  window.__sweepCache = [];
  if ($("sweepPath")) $("sweepPath").value = "";
  if ($("sweepValues")) $("sweepValues").value = "";
  renderSweepResults([]);
  toast("Cleared", "ok", "Sweep");
}


    /* ---------- Assembler (legacy master_prompt) ---------- */
    function buildMasterPrompt(data){
      const parts = [];
      const mode = data.prompt_profile?.mode || "photoreal";
      parts.push(`${mode} image`);

      const pr = data.prompt_profile?.priority;
      const priority = Array.isArray(pr) && pr.length ? pr : ["composition","subject","clothing","accessories","lighting","background","camera","style","constraints"];
      const add = (t)=>{ if (t && String(t).trim()) parts.push(String(t).trim()); };

      const pick = (key) => {
        if (key === "identity"){
          const i = data.identity || {};
          if (i.identity_strength) add(`identity lock: ${i.identity_strength}`);
          if (i.distinctive_features) add(i.distinctive_features);
          if (Array.isArray(i.do_not_change) && i.do_not_change.length) add(`do not change: ${i.do_not_change.join(", ")}`);
          return;
        }
        if (key === "composition"){
          const c = data.composition || {};
          add(c.shot_type); add(c.body_visibility); add(c.framing); add(c.orientation);
          add(c.subject_position); add(c.camera_height); add(c.perspective);
          return;
        }
        if (key === "subject"){
          const s = data.subject || {};
          add(s.gender); add(s.age);
          if (s.ethnicity && s.ethnicity !== "unspecified") add(s.ethnicity);
          if (s.skin?.details) add(s.skin.details);
          if (s.hair?.details) add(s.hair.details);
          return;
        }
        if (key === "clothing"){
          const c = data.clothing || {};
          add(c.top); add(c.bottom);
          if (c.outerwear && c.outerwear !== "none") add(c.outerwear);
          if (c.dress && c.dress !== "none") add(c.dress);
          if (c.footwear && c.footwear !== "none") add(c.footwear);
          if (Array.isArray(c.materials) && c.materials.length) add(`materials: ${c.materials.join(", ")}`);
          if (c.notes) add(c.notes);
          return;
        }
        if (key === "accessories"){
          const a = data.accessories || {};
          if (Array.isArray(a.items) && a.items.length && a.items[0] !== "none") add(`accessories: ${a.items.join(", ")}`);
          if (a.details) add(a.details);
          return;
        }
        if (key === "lighting"){
          const l = data.lighting || {};
          add([l.type,l.direction,l.quality,l.tone].filter(Boolean).join(", "));
          if (l.notes) add(l.notes);
          return;
        }
        if (key === "background"){
          const b = data.background || {};
          add([b.location_type,b.scene].filter(Boolean).join(", "));
          return;
        }
        if (key === "camera"){
          const c = data.camera || {};
          add([c.photo_style,c.focal_length, c.depth_of_field].filter(Boolean).join(", "));
          return;
        }
        if (key === "style"){
          const s = data.style || {};
          add([s.genre,s.color_grading, s.contrast, s.sharpness].filter(Boolean).join(", "));
          return;
        }
        if (key === "constraints"){
          const c = data.constraints || {};
          if (Array.isArray(c.must_include) && c.must_include.length) add(`must include: ${c.must_include.join(", ")}`);
          if (Array.isArray(c.avoid) && c.avoid.length) add(`avoid: ${c.avoid.join(", ")}`);
          return;
        }
        if (key.startsWith("subject.identity")){
          const i = data.subject?.identity;
          if (!i) return;
          add(i.core_description);
          if (i.identity_lock) add("strict identity lock");
          add(i.skin?.texture);
          add(i.hair?.style);
          return;
        }
      };
      priority.forEach(pick);

      const prefix = data.prompt_output?.user_prefix;
      return (prefix && prefix.trim()) ? `${prefix.trim()}, ${parts.join(", ")}` : parts.join(", ");
    }

    function applyMasterPrompt(outData, includeMaster){
      if (!outData.prompt_output) outData.prompt_output = { user_prefix:"", negative_prompt:"" };
      if (includeMaster){
        outData.prompt_output.master_prompt = buildMasterPrompt(outData);
      } else if (outData.prompt_output && "master_prompt" in outData.prompt_output){
        delete outData.prompt_output.master_prompt;
      }
    }

    /* ---------- State ---------- */
    let currentTemplateName = "ChatGPT Optimized";
    let currentData = deepClone(TEMPLATE_BASES[currentTemplateName]);
    let baseData = deepClone(currentData);

    let includeMaster = false;
    let expertUnlocked = false;
    let godUnlocked = false;

    let saveAsJson = false;
    let chatName = "";
    let purpose = "";

    let step0Inject = true;
    let step0Detect = true;

    let showOnlyModified = false;
    let autoSaveRuns = false;

    let strictValidation = true;

    let lastDerived = null; // {promptPack, json, lint, manifest, doc}

    function isUltraEliteTemplate(){ return currentTemplateName === "Ultra Elite (ChatGPT5.2)"; }
    function refreshStep4Visibility(){ $("card4").style.display = isUltraEliteTemplate() ? "block" : "none"; }

    /* ---------- Template / preset selects ---------- */
    function populateTemplates(){
      const sel = $("templateSelect");
      sel.innerHTML = "";
      Object.keys(TEMPLATE_BASES).forEach(name=>{
        const opt=document.createElement("option");
        opt.value=name; opt.textContent=name;
        sel.appendChild(opt);
      });
      $("templateDesc").textContent = TEMPLATE_INFO[currentTemplateName] || "";
    }
    function populatePresets(){
      const sel = $("presetSelect");
      sel.innerHTML = "";
      BUILTIN_PRESETS.forEach(p=>{
        const opt=document.createElement("option");
        opt.value = `builtin:${p.name}`;
        opt.textContent = p.name;
        sel.appendChild(opt);
      });
      const users = loadUserPresets();
      if (users.length){
        const sep = document.createElement("option");
        sep.disabled = true;
        sep.textContent = "──────── User presets ────────";
        sel.appendChild(sep);
        users.forEach(p=>{
          const opt=document.createElement("option");
          opt.value = `user:${p.name}`;
          opt.textContent = p.name;
          sel.appendChild(opt);
        });
      }
      renderPresetManager();
    }

    function renderPresetManager(){
      const box = $("presetManager");
      if (!box) return;
      const q = String($("presetSearch")?.value || "").toLowerCase().trim();

      const users = loadUserPresets();
      const builtins = BUILTIN_PRESETS.map(p=>({ name:p.name, builtin:true, preset:p.preset, saved_at:null }));
      const all = builtins.concat(users.map(u=>({ name:u.name, builtin:false, preset:u.preset, saved_at:u.saved_at || null })));

      const list = all.filter(p => !q || String(p.name).toLowerCase().includes(q));
      box.innerHTML = "";

      if (!list.length){
        box.innerHTML = `<div class="small">No presets match.</div>`;
        return;
      }

      list.forEach(item=>{
        const row = document.createElement("div");
        row.className = "listitem";

        const left = document.createElement("div");
        left.className = "liLeft";
        const meta = item.builtin ? "Built-in" : ("User" + (item.saved_at ? ` • ${new Date(item.saved_at).toLocaleString()}` : ""));
        left.innerHTML = `<div class="liTitle">${escapeHtml(item.name)}</div><div class="liMeta">${escapeHtml(meta)}</div>`;

        const right = document.createElement("div");
        right.className = "liRight";

        const loadBtn = document.createElement("button");
        loadBtn.className = "btn tiny";
        loadBtn.textContent = "Load";
        loadBtn.onclick = ()=>{
          $("presetSelect").value = `${item.builtin ? "builtin" : "user"}:${item.name}`;
          applyPresetFromSelection();
          toast(`Preset loaded: ${item.name}`, "ok", "Presets");
          closeDrawer();
        };
        right.appendChild(loadBtn);

        if (!item.builtin){
          const renBtn = document.createElement("button");
          renBtn.className = "btn tiny";
          renBtn.textContent = "Rename";
          renBtn.onclick = ()=>{
            const next = prompt("Rename preset", item.name);
            const nn = String(next || "").trim();
            if (!nn || nn === item.name) return;
            const allNames = new Set(users.map(u=>u.name));
            if (allNames.has(nn)){
              toast("Name already exists", "err", "Presets");
              return;
            }
            const idx = users.findIndex(u=>u.name === item.name);
            if (idx >= 0){
              users[idx].name = nn;
              saveUserPresets(users);
              populatePresets();
              renderPresetManager();
              toast("Preset renamed", "ok", "Presets");
            }
          };
          right.appendChild(renBtn);

          const delBtn = document.createElement("button");
          delBtn.className = "btn tiny danger";
          delBtn.textContent = "Delete";
          delBtn.onclick = ()=>{
            if (!confirm(`Delete preset "${item.name}"?`)) return;
            const next = users.filter(u=>u.name !== item.name);
            saveUserPresets(next);
            populatePresets();
            renderPresetManager();
            toast("Preset deleted", "ok", "Presets");
          };
          right.appendChild(delBtn);
        }

        row.appendChild(left);
        row.appendChild(right);
        box.appendChild(row);
      });
    }

    /* ---------- Step 0 init ---------- */
    (function initStep0(){
      const sel = $("imageTypeSelect");
      if (!sel) return;
      Object.keys(IMAGE_ANALYSIS_PROMPTS).forEach(k=>{
        const opt=document.createElement("option");
        opt.value=k; opt.textContent=k;
        sel.appendChild(opt);
      });
      sel.value = "Portrait Photography";

      function updateCustomVisibility(){
        const isCustom = sel.value === "Custom";
        $("customTypeRow").style.display = isCustom ? "grid" : "none";
        $("customPromptRow").style.display = isCustom ? "grid" : "none";
      }
      sel.addEventListener("change", updateCustomVisibility);
      updateCustomVisibility();

      // Upload JSON uses shared hidden file input
      if ($("uploadStep0JsonBtn")) $("uploadStep0JsonBtn").onclick=()=>{
        const fi = $("fileInput");
        fi.onchange = async ()=>{
          try{
            const file = fi.files && fi.files[0];
            if (!file) return;
            const txt = await file.text();
            $("step0Json").value = txt;
            toast("Loaded JSON into Step 0", "ok", "Upload");
          }catch(_){
            toast("Upload failed", "err", "Upload");
          }finally{
            fi.value = "";
          }
        };
        fi.click();
      };

      if ($("clearStep0JsonBtn")) $("clearStep0JsonBtn").onclick=()=>{
        $("step0Json").value = "";
        toast("Cleared Step 0 JSON", "ok", "Step 0");
      };

      // Inject toggle
      function setInject(on){
        step0Inject = !!on;
        $("injectSwitch").classList.toggle("on", step0Inject);
        $("injectSwitch").setAttribute("aria-checked", step0Inject ? "true" : "false");
        saveState();
      }
      if ($("injectSwitch")) $("injectSwitch").onclick=()=> setInject(!step0Inject);
      setInject(true);

      // Detect toggle
      function setDetect(on){
        step0Detect = !!on;
        $("detectSwitch").classList.toggle("on", step0Detect);
        $("detectSwitch").setAttribute("aria-checked", step0Detect ? "true" : "false");
        saveState();
      }
      if ($("detectSwitch")) $("detectSwitch").onclick=()=> setDetect(!step0Detect);
      setDetect(true);

      // Copy merged
      if ($("copyMergedBtn")) $("copyMergedBtn").onclick=async ()=>{
        const txt = $("mergedOut").textContent || "";
        if (!txt.trim()){ toast("Nothing to copy", "err", "Step 0"); return; }
        const ok = await copyToClipboard(txt);
        ok ? toast("Copied merged output", "ok", "Step 0") : toast("Copy failed", "err", "Clipboard");
      };
    })();

    /* ---------- master_prompt toggle ---------- */
    function setMasterSwitch(on){
      includeMaster = !!on;
      const sw = $("masterSwitch");
      sw.classList.toggle("on", includeMaster);
      sw.setAttribute("aria-checked", includeMaster ? "true" : "false");
      saveState();
    }
    $("masterSwitch").onclick=()=>{
      setMasterSwitch(!includeMaster);
      toast(includeMaster ? "master_prompt enabled" : "master_prompt disabled", "ok", "Assembler");
    };

    /* ---------- Save-as-JSON toggle ---------- */
    function setSaveSwitch(on){
      saveAsJson = !!on;
      const sw = $("saveSwitch");
      sw.classList.toggle("on", saveAsJson);
      sw.setAttribute("aria-checked", saveAsJson ? "true" : "false");
      saveState();
    }
    $("saveSwitch").onclick=()=> setSaveSwitch(!saveAsJson);

/* ---------- Diff filter toggle (show only modified fields) ---------- */
function setDiffSwitch(on){
  showOnlyModified = !!on;
  const sw = $("diffSwitch");
  if (sw){
    sw.classList.toggle("on", showOnlyModified);
    sw.setAttribute("aria-checked", showOnlyModified ? "true" : "false");
  }
  renderStep2(); if ($("card3")) renderStep3(); if ($("card4")) renderStep4();
  saveState();
}
if ($("diffSwitch")) $("diffSwitch").onclick=()=> setDiffSwitch(!showOnlyModified);

/* ---------- Reference images included toggle ---------- */
function setRefSwitch(on){
  ensureDefaultsForV1(currentData);
  setByPath(currentData, "references.images_included", !!on);
  const sw = $("refSwitch");
  if (sw){
    sw.classList.toggle("on", !!on);
    sw.setAttribute("aria-checked", on ? "true" : "false");
  }
  refreshOutput();
  saveState();
}
if ($("refSwitch")) $("refSwitch").onclick=()=>{
  const cur = !!getByPath(currentData, "references.images_included");
  setRefSwitch(!cur);
  toast(!cur ? "Reference images enabled" : "Reference images disabled", "ok", "Refs");
};

/* ---------- Run-id lock (repro) ---------- */
function setRunIdLock(on){
  lockRunId = !!on;
  ensureDefaultsForV1(currentData);
  if (lockRunId){
    const cur = String(getByPath(currentData, "meta.run_id") || "").trim();
    setByPath(currentData, "meta.run_id", cur || uuidv4());
  }else{
    // allow compile-time auto run_id
    try{ deleteByPath(currentData, "meta.run_id"); }catch(_){}
  }
  const sw = $("runIdLockSwitch");
  if (sw){
    sw.classList.toggle("on", lockRunId);
    sw.setAttribute("aria-checked", lockRunId ? "true" : "false");
  }
  refreshOutput();
  saveState();
}
if ($("runIdLockSwitch")) $("runIdLockSwitch").onclick=()=>{
  setRunIdLock(!lockRunId);
  toast(lockRunId ? "Run ID locked" : "Run ID unlocked", "ok", "Repro");
};
if ($("newRunIdBtn")) $("newRunIdBtn").onclick=()=>{
  ensureDefaultsForV1(currentData);
  setByPath(currentData, "meta.run_id", uuidv4());
  if (!lockRunId) setRunIdLock(true);
  refreshOutput();
  saveState();
  toast("New run ID generated", "ok", "Repro");
};



/* ---------- Strict validation toggle ---------- */
function setStrictSwitch(on){
  strictValidation = !!on;
  const sw = $("strictSwitch");
  if (sw){
    sw.classList.toggle("on", strictValidation);
    sw.setAttribute("aria-checked", strictValidation ? "true" : "false");
  }
  refreshOutput();
  saveState();
}
if ($("strictSwitch")) $("strictSwitch").onclick=()=>{
  setStrictSwitch(!strictValidation);
  toast(strictValidation ? "Strict validation enabled" : "Strict validation disabled", "ok", "Schema");
};

    /* ---------- Auto-save runs toggle ---------- */
    function setAutoSaveSwitch(on){
      autoSaveRuns = !!on;
      const sw = $("autoSaveSwitch");
      if (sw){
        sw.classList.toggle("on", autoSaveRuns);
        sw.setAttribute("aria-checked", autoSaveRuns ? "true" : "false");
      }
      saveState();
    }
    if ($("autoSaveSwitch")) $("autoSaveSwitch").onclick=()=> setAutoSaveSwitch(!autoSaveRuns);

    /* ---------- Field grouping ---------- */
    function groupPaths(paths){
      const groups = {};
      for (const p of paths){
        const meta = FIELD_META[p] || {};
        const cat = meta.category || "Output & Prompt";
        if (!groups[cat]) groups[cat] = [];
        groups[cat].push(p);
      }
      const cats = Object.keys(groups).sort((a,b)=>{
        const ia = CATEGORY_ORDER.indexOf(a), ib = CATEGORY_ORDER.indexOf(b);
        const ra = ia === -1 ? 999 : ia, rb = ib === -1 ? 999 : ib;
        if (ra !== rb) return ra - rb;
        return a.localeCompare(b);
      });
      cats.forEach(cat=>{
        groups[cat].sort((a,b)=>{
          const la = FIELD_META[a]?.label || a;
          const lb = FIELD_META[b]?.label || b;
          return la.localeCompare(lb);
        });
      });
      return {cats, groups};
    }

    function closeOtherDetails(container, opened){
      container.querySelectorAll("details").forEach(d=>{
        if (d !== opened) d.open = false;
      });
    }
    function closeOtherValueDetails(groupEl, openedRow){
      groupEl.querySelectorAll(".fieldMore").forEach(m=>{
        if (m !== openedRow) m.classList.remove("open");
      });
    }

    function normalizeSuggestions(path){
      const meta = FIELD_META[path] || { suggestions:["(blank)"] };
      const suggestions = Array.isArray(meta.suggestions) ? meta.suggestions.slice() : [];
      const out = ["(keep)", ...suggestions.filter(x=>x!=="(keep)" && x!=="Custom…" && x!=="(omit)"), "Custom…", "(omit)"];
      return [...new Set(out)];
    }

    function formatOptionLabel(path, rawValue){
      const info = VALUE_INFO[path]?.[rawValue];
      if (info?.short) return `${rawValue} — ${info.short}`;
      return rawValue;
    }

    function buildScalarControl(path, onValueChanged){
      const wrap = document.createElement("div");
      const currentValue = getByPath(currentData, path);
      const str = (currentValue === undefined || currentValue === null) ? "" : String(currentValue);

      const sel = document.createElement("select");
      const opts = normalizeSuggestions(path);

      opts.forEach(v=>{
        const o=document.createElement("option");
        o.value=v;

        // descriptor enrichment for enum options
        if (v !== "(keep)" && v !== "Custom…" && v !== "(omit)"){
          o.textContent = formatOptionLabel(path, v);
        } else {
          o.textContent = v;
        }
        sel.appendChild(o);
      });

      const sugg = (FIELD_META[path]?.suggestions || []);
      if (str && sugg.includes(str)) sel.value = str;
      else if (!str) sel.value = "(keep)";
      else sel.value = "Custom…";

      const input = document.createElement("input");
      input.placeholder = "Custom value…";
      input.value = (sel.value === "Custom…") ? str : "";
      input.style.marginTop = "8px";
      input.style.display = (sel.value === "Custom…") ? "block" : "none";

      sel.addEventListener("change", ()=>{
        if (sel.value === "(omit)"){
          const parts = path.split(".");
          let cur = currentData;
          for (let i=0;i<parts.length-1;i++){
            if (!(parts[i] in cur)) return;
            cur = cur[parts[i]];
          }
          delete cur[parts[parts.length-1]];
          input.style.display = "none";
          saveState();
          onValueChanged?.();
          return;
        }
        if (sel.value === "Custom…"){
          input.style.display = "block";
          setByPath(currentData, path, input.value);
          saveState();
          onValueChanged?.();
          return;
        }
        input.style.display = "none";
        if (sel.value === "(keep)") return;
        setByPath(currentData, path, sel.value);
        saveState();
        onValueChanged?.();
      });

      input.addEventListener("input", ()=>{
        if (sel.value !== "Custom…") return;
        setByPath(currentData, path, input.value);
        saveState();
        onValueChanged?.();
      });

      wrap.appendChild(sel);
      wrap.appendChild(input);
      return wrap;
    }

    function buildArrayControl(path, onValueChanged){
      const wrap = document.createElement("div");
      const ta = document.createElement("textarea");
      ta.value = (getByPath(currentData, path) || []).join("\n");
      ta.addEventListener("input", ()=>{
        const lines = ta.value.split("\n").map(s=>s.trim()).filter(Boolean);
        setByPath(currentData, path, lines);
        saveState();
        onValueChanged?.();
      });
      wrap.appendChild(ta);
      return wrap;
    }

    function buildControl(path, onValueChanged){
  const v = getByPath(currentData, path);
  const t = (FIELD_META[path]?.type || FIELD_TYPES[path] || (Array.isArray(v) ? "array" : typeof v));

  if (t === "array") return buildArrayControl(path, onValueChanged);

  if (t === "boolean"){
    const cur = (v === undefined) ? false : !!v;
    const sel=document.createElement("select");
    ["true","false"].forEach(x=>{
      const o=document.createElement("option"); o.value=x; o.textContent=x; sel.appendChild(o);
    });
    sel.value = String(cur);
    sel.addEventListener("change", ()=> { setByPath(currentData, path, sel.value==="true"); saveState(); onValueChanged?.(); });
    const w=document.createElement("div"); w.appendChild(sel);
    return w;
  }

  return buildScalarControl(path, onValueChanged);
}

function renderValueInfoBox(path, selectedValue){
      const meta = FIELD_META[path] || {};
      const vinfo = VALUE_INFO[path]?.[selectedValue];

      const box = document.createElement("div");
      box.className = "valueInfoBox";

      const chip = selectedValue ? `<span class="chip">${escapeHtml(selectedValue)}</span>` : `<span class="chip">(none)</span>`;

      const headerHtml = `
        <div class="hdr">
          <b>Value info</b>
          ${chip}
          ${vinfo?.short ? `<span class="chip">${escapeHtml(vinfo.short)}</span>` : ""}
        </div>
      `;

      const bodyParts = [];
      bodyParts.push(`<div class="body">${escapeHtml(meta.desc || "")}</div>`);

      if (vinfo){
        bodyParts.push(`<div class="body"><div class="k">Description</div>${escapeHtml(vinfo.long || "")}</div>`);
        if (Array.isArray(vinfo.recommendations) && vinfo.recommendations.length){
          bodyParts.push(`<div class="body"><div class="k">Recommendations</div><ul>${vinfo.recommendations.map(x=>`<li>${escapeHtml(x)}</li>`).join("")}</ul></div>`);
        }
        if (vinfo.most_common){
          bodyParts.push(`<div class="body"><div class="k">Most common</div>${escapeHtml(vinfo.most_common)}</div>`);
        }
        if (vinfo.reasoning){
          bodyParts.push(`<div class="body"><div class="k">Reasoning</div>${escapeHtml(vinfo.reasoning)}</div>`);
        }
      } else {
        const fallback = [];
        if (meta.recommendation) fallback.push(`Suggestion: ${meta.recommendation}`);
        if (fallback.length){
          bodyParts.push(`<div class="body"><div class="k">Notes</div>${escapeHtml(fallback.join(" • "))}</div>`);
        } else {
          bodyParts.push(`<div class="body"><div class="k">Notes</div>No value-specific info available.</div>`);
        }
      }

      box.innerHTML = headerHtml + bodyParts.join("");
      return box;
    }

    function renderFieldRow(groupBody, path){
      const meta = FIELD_META[path] || { label:path, desc:"" };

      const row = document.createElement("div");
      row.className = "fieldRow";
      row.dataset.path = path;
      row.dataset.label = (meta.label || path).toLowerCase();

      const top = document.createElement("div");
      top.className = "fieldTop";

      const lab = document.createElement("div");
      lab.className = "lab";
      lab.textContent = meta.label || path;

      const pth = document.createElement("div");
      pth.className = "path";
      pth.textContent = path;

      const moreBtn = document.createElement("button");
      moreBtn.className = "fieldMoreBtn";
      moreBtn.textContent = "More";

      top.appendChild(lab);
      top.appendChild(pth);
      top.appendChild(moreBtn);

      const ctl = document.createElement("div");
      ctl.style.marginTop = "10px";

      const more = document.createElement("div");
      more.className = "fieldMore";

      function refreshMoreBox(){
        more.innerHTML = "";
        const v = getByPath(currentData, path);
        let selected = "";
        if (Array.isArray(v)) selected = "(list)";
        else if (typeof v === "boolean") selected = String(v);
        else selected = (v === undefined || v === null) ? "" : String(v);
        more.appendChild(renderValueInfoBox(path, selected));
      }

      const control = buildControl(path, ()=>{
        if (more.classList.contains("open")){
          refreshMoreBox();
        }
      });
      ctl.appendChild(control);

      moreBtn.onclick = ()=>{
        const willOpen = !more.classList.contains("open");
        closeOtherValueDetails(groupBody, more);
        more.classList.toggle("open", willOpen);
        if (willOpen){
          refreshMoreBox();
          more.scrollIntoView({behavior:"smooth", block:"nearest"});
        }
      };

      row.appendChild(top);
      row.appendChild(ctl);
      row.appendChild(more);
      groupBody.appendChild(row);
    }

    function renderFieldGroups(container, paths, opts={}){
  const showUndefined = !!opts.showUndefined;
  const onlyModified = !!opts.onlyModified;

  container.innerHTML = "";
  const {cats, groups} = groupPaths(paths);

  const isModified = (path)=>{
    if (!onlyModified) return true;
    const cur = getByPath(currentData, path);
    const base = getByPath(baseData, path);
    return !deepEqual(cur, base);
  };

  cats.forEach(cat=>{
    const filtered = groups[cat].filter(path=>{
      const exists = getByPath(currentData, path) !== undefined;
      if (!showUndefined && !exists) return false;
      if (!isModified(path)) return false;
      return true;
    });

    if (!filtered.length) return;

    const det = document.createElement("details");
    det.className = "group";
    det.open = false;

    det.addEventListener("toggle", ()=>{
      if (!det.open) return;
      closeOtherDetails(container, det);
    });

    const sum = document.createElement("summary");
    sum.innerHTML = `<span class="groupTitle">${escapeHtml(cat)}</span><span class="groupMeta">${filtered.length} fields</span>`;
    det.appendChild(sum);

    const body = document.createElement("div");
    body.className = "section";

    filtered.forEach(path=>{
      renderFieldRow(body, path);
    });

    det.appendChild(body);
    container.appendChild(det);
  });
}

function renderStep2(){
      renderFieldGroups($("commonFields"), COMMON_FIELDS, { showUndefined:true, onlyModified: showOnlyModified });
    }

    function renderStep3(){
      if (!$("card3")) return;
      const expertFieldsEl = $("expertFields");
      expertFieldsEl.innerHTML = "";

      if (!expertUnlocked){
        $("expertHint").textContent = "Locked";
        expertFieldsEl.innerHTML = `<div class="help-inline">Locked. Unlock Expert Mode in Step 2.</div>`;
        return;
      }
      $("expertHint").textContent = (godUnlocked ? "Unlocked (God enabled)" : "Unlocked");

      inferSchemaRegistry();
      ensureMetaForAllLeafPaths(currentData);
      const schemaPaths = (SCHEMA_PATHS_BY_TEMPLATE[currentTemplateName] || ALL_SCHEMA_PATHS).filter(p => p !== "prompt_output.master_prompt");
      const setCommon = new Set(COMMON_FIELDS);
      const expertPaths = schemaPaths.filter(p => !setCommon.has(p));
      renderFieldGroups(expertFieldsEl, expertPaths, { showUndefined:true, onlyModified: showOnlyModified });
    }

    function renderStep4(){
      if (!$("card4")) return;
      const godFieldsEl = $("godFields");
      godFieldsEl.innerHTML = "";
      if (!isUltraEliteTemplate()) return;
      if (!expertUnlocked){
        godFieldsEl.innerHTML = `<div class="help-inline">Unlock Expert Mode first.</div>`;
        return;
      }
      inferSchemaRegistry();
      ensureMetaForAllLeafPaths(currentData);
      const schemaPaths = (SCHEMA_PATHS_BY_TEMPLATE[currentTemplateName] || ALL_SCHEMA_PATHS).filter(p => p !== "prompt_output.master_prompt");
      const setCommon = new Set(COMMON_FIELDS);
      const paths = schemaPaths.filter(p => !setCommon.has(p));
      renderFieldGroups(godFieldsEl, paths, { showUndefined:true, onlyModified: showOnlyModified });

      if (!godUnlocked){
        const msg = document.createElement("div");
        msg.className = "help-inline";
        msg.textContent = "Locked. Press “Unlock God Mode” in Step 3.";
        godFieldsEl.prepend(msg);
      }
    }

    /* ---------- Template apply / preset apply ---------- */
    function applyTemplate(name){
      currentTemplateName = name;
      currentData = deepClone(TEMPLATE_BASES[name]);
      baseData = deepClone(currentData);

      // standardize meta
      currentData.meta = currentData.meta || {};
      currentData.meta.app_name = APP_NAME;
      currentData.meta.schema_version = APP_VERSION;

      $("templateDesc").textContent = TEMPLATE_INFO[currentTemplateName] || "";
      renderStep2(); if ($("card3")) renderStep3(); if ($("card4")) renderStep4();
      refreshOutput();
      saveState();
    }

    function applyPresetFromSelection(){
      const val = $("presetSelect").value || "builtin:— None —";
      if (val.startsWith("builtin:")){
        const name = val.slice("builtin:".length);
        const preset = BUILTIN_PRESETS.find(p=>p.name===name);
        if (!preset) return;
        preset.apply(currentData);
        return;
      }
      if (val.startsWith("user:")){
        const name = val.slice("user:".length);
        const presets = loadUserPresets();
        const p = presets.find(x=>x.name===name);
        if (!p) return;
        deepMerge(currentData, deepClone(p.overlay));
      }
    }

    /* ---------- God mode unlock (forces Ultra Elite and migrates settings) ---------- */
    function migrateToUltraElitePreservingSettings(){
      const prevTemplate = currentTemplateName;
      const prevData = deepClone(currentData);

      if (prevTemplate !== "Ultra Elite (ChatGPT5.2)"){
        currentTemplateName = "Ultra Elite (ChatGPT5.2)";
        const ultraBase = deepClone(TEMPLATE_BASES[currentTemplateName]);

        deepMerge(ultraBase, prevData);

        ultraBase.meta = ultraBase.meta || {};
        ultraBase.meta.app_name = APP_NAME;
        ultraBase.meta.schema_version = APP_VERSION;
        ultraBase.meta.template_type = "ultra_elite";
        ultraBase.meta.engine_target = "chatgpt";

        currentData = ultraBase;
        baseData = deepClone(ultraBase);

        $("templateSelect").value = currentTemplateName;
        $("templateDesc").textContent = TEMPLATE_INFO[currentTemplateName] || "";
        toast("Template switched to Ultra Elite", "ok", "God Mode");
      }
    }

    /* ---------- Output (Prompt Pack compiler + JSON export) ---------- */
function buildCanonicalDocForExport(){
  const out = deepClone(currentData);

  // Ensure v1 defaults and shims (refs, crop guards, constraint aliases, prompt_output.directive)
  ensureDefaultsForV1(out);

  // reproducibility
  if (!lockRunId){
    try{ deleteByPath(out, "meta.run_id"); }catch(_){ }
  }else{
    const curRid = String(getByPath(out, "meta.run_id") || "").trim();
    setByPath(out, "meta.run_id", curRid || uuidv4());
  }

  // standard meta
  out.meta = out.meta || {};
  out.meta.app_name = APP_NAME;
  out.meta.schema_version = APP_VERSION;
  out.meta.schema_id = out.meta.schema_id || SCHEMA_ID_V1;
  out.meta.template = currentTemplateName;
  out.meta.chat_name = (chatName || "").trim();
  out.meta.purpose = (purpose || "").trim();
  out.meta.generated_at = new Date().toISOString();

  // legacy master_prompt (optional; kept for backwards compatibility)
  applyMasterPrompt(out, includeMaster);

  // legacy identity lock helper
  const dnc = getByPath(out, "identity.do_not_change");
  if (Array.isArray(dnc) && dnc.length){
    ensureArrayContains(out, "constraints.must_include", "strict identity lock");
    dnc.forEach(t => ensureArrayContains(out, "constraints.avoid", `do not change ${t}`));
  }

  // v1: keep aliases in sync at export/compile time (safe union)
  ensureDefaultsForV1(out);

  // Harden against missing/invalid constraints (prevents export pipeline abort)
  const c = (typeof isPlainObject === "function" && isPlainObject(out.constraints)) ? out.constraints : (out.constraints = {});
  const _uniq = (typeof uniq === "function") ? uniq : (arr => {
    const outA = [];
    const seen = new Set();
    for (const v of (Array.isArray(arr) ? arr : [])){
      if (v === undefined || v === null) continue;
      const isStr = (typeof v === "string");
      const val = isStr ? v.trim() : v;
      const key = isStr ? val : JSON.stringify(val);
      if (!key) continue;
      if (seen.has(key)) continue;
      seen.add(key);
      outA.push(val);
    }
    return outA;
  });

  const hardU = _uniq([...(c.must_include||[]), ...(c.hard||[])]);
  const negU  = _uniq([...(c.avoid||[]), ...(c.negative||[])]);
  c.must_include = hardU.slice();
  c.hard        = hardU.slice();
  c.avoid       = negU.slice();
  c.negative    = negU.slice();
const stripped = stripEmpties(out) || {};

  // compile Prompt Pack + hashes
  const compiled = compilePromptPack(stripped, { chatName, purpose, templateName: currentTemplateName });
  stripped.meta = stripped.meta || {};
  stripped.meta.run_id = compiled.manifest.run_id;
  stripped.meta.doc_hash = compiled.manifest.doc_hash;
  stripped.meta.prompt_pack_hash = compiled.manifest.prompt_pack_hash;

  const json = JSON.stringify(stripped, null, 2);
  return { stripped, json, compiled };
}

function generateOutputText(){
  const { stripped, json, compiled } = buildCanonicalDocForExport();
  lastDerived = { doc: stripped, json, ...compiled };

  const mode = $("outputMode").value;
  const mp = stripped?.prompt_output?.master_prompt || "";

  if (mode === "prompt_pack") return compiled.promptPack;
  if (mode === "prompt_pack_and_json") return `PROMPT_PACK:
${compiled.promptPack}

JSON:
${json}`;
  if (mode === "full_json") return json;

  if (mode === "json_patch"){
    const base = stripEmpties(deepClone(baseData)) || {};
    const patch = computeJsonPatch(base, stripped);
    return JSON.stringify(patch, null, 2);
  }

  if (mode === "json_schema"){
    return JSON.stringify(generateJsonSchema(currentTemplateName), null, 2);
  }
  if (mode === "json_schema_and_json"){
    const sj = JSON.stringify(generateJsonSchema(currentTemplateName), null, 2);
    return "JSON_SCHEMA:\n" + sj + "\n\nJSON:\n" + json;
  }

  if (mode === "prompt_only") return (mp || "").trim();
  if (mode === "prompt_and_json") return `MASTER_PROMPT:
${(mp||"").trim()}

JSON:
${json}`;

  if (mode === "exec_json"){
    const n = (chatName || "").trim();
    const p = (purpose || "").trim();
    return `Provided: JSON
Task: Use the built-in image generator to render 1 image using this JSON.
Rules: Output ONLY the image. No explanations. No text overlays/logos/watermarks.
Name: ${n || "(none)"}
Purpose: ${p || "(none)"}

${json}`;
  }

  return JSON.stringify({
    meta: {
      app_name: APP_NAME,
      app_version: APP_VERSION,
      template: currentTemplateName,
      include_master_prompt: includeMaster,
      output_mode: mode
    },
    manifest: compiled.manifest,
    lint: compiled.lint,
    prompt_pack_preview: compiled.promptPack,
    json: stripped
  }, null, 2);
}

function refreshOutput(){
  const out = generateOutputText();
  $("outMain").textContent = out || "";
  $("outHint").textContent = $("outputMode").value;

  // Lint panel (never included in copied prompt pack unless user copies it manually)
  const box = $("lintBox");
  const lint = lastDerived?.lint;
  if (box && lint){
    const lines = [];
    if (lint.errors?.length){
      lines.push(`<div><b>Errors</b><ul>${lint.errors.map(x=>`<li>${escapeHtml(x)}</li>`).join("")}</ul></div>`);
    }
    if (lint.warnings?.length){
      lines.push(`<div><b>Warnings</b><ul>${lint.warnings.map(x=>`<li>${escapeHtml(x)}</li>`).join("")}</ul></div>`);
    }
    if (lint.notes?.length){
      lines.push(`<div><b>Notes</b><ul>${lint.notes.map(x=>`<li>${escapeHtml(x)}</li>`).join("")}</ul></div>`);
    }
    if (lines.length){
      box.innerHTML = lines.join("");
      box.style.display = "block";
    } else {
      box.innerHTML = "";
      box.style.display = "none";
    }
  }

  saveState();
}

    /* ---------- Expand output ---------- */
    $("expandBtn").onclick=()=>{
      const pre = $("outMain").parentElement;
      const cur = pre.style.maxHeight;
      pre.style.maxHeight = (cur && cur !== "56vh") ? "56vh" : "80vh";
      toast("Toggled output expand", "ok", "Output");
    };

    /* ---------- Save-as-JSON logic (unchanged rules) ---------- */
    function nowStamp(){
      const d = new Date();
      const pad = (n)=>String(n).padStart(2,"0");
      return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
    }

    function saveFileWithLogic(){
  const filename = ($("filenameInput").value || "").trim();
  if (!filename){
    toast("Set a filename first", "err", "Save");
    return;
  }

  if (saveAsJson){
    const { json } = buildCanonicalDocForExport();
    const blob = new Blob([json], {type:"application/json"});
    const a=document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename.endsWith(".json") ? filename : `${filename}.json`;
    a.click();
    URL.revokeObjectURL(a.href);
    toast("Saved JSON file", "ok", "Save");
    return;
  }

  // fallback: save current output as plain text
  refreshOutput();
  const txt = $("outMain").textContent || "";
  const blob = new Blob([txt], {type:"text/plain"});
  const a=document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
  toast("Saved file", "ok", "Save");
}
$("saveFileBtn").onclick=saveFileWithLogic;


    /* ---------- Step open state ---------- */
    function getStepOpenState(){
      const o = {};
      STEP_IDS.forEach(id=>{ if ($(id)) o[id] = $(id).open; });
      return o;
    }
    function setStepOpenState(s){
      if (!s) return;
      STEP_IDS.forEach(id=>{ if ($(id)) $(id).open = !!s[id]; });
    }
    function enforceSingleOpenStep(){
      const openIds = STEP_IDS.filter(id => $(id) && $(id).open);
      if (openIds.length <= 1) return;
      openIds.slice(1).forEach(id => { if ($(id)) $(id).open = false; });
    }

    /* ---------- Search + Jump ---------- */
    function filterExpertFields(query){
      query = (query||"").trim().toLowerCase();
      const container = $("expertFields");
      const groups = container.querySelectorAll("details.group");
      groups.forEach(g=>{
        const rows = g.querySelectorAll(".fieldRow");
        let any = false;
        rows.forEach(r=>{
          const label = r.dataset.label || "";
          const path = (r.dataset.path || "").toLowerCase();
          const match = !query || label.includes(query) || path.includes(query);
          r.style.display = match ? "" : "none";
          if (match) any = true;
        });
        g.style.display = any ? "" : "none";
      });
    }
    function jumpToFirstMatch(){
      const q = $("fieldSearch").value.trim().toLowerCase();
      if (!q) return;
      const container = $("expertFields");
      const first = [...container.querySelectorAll(".fieldRow")].find(r=>{
        if (r.style.display === "none") return false;
        const label = r.dataset.label || "";
        const path = (r.dataset.path || "").toLowerCase();
        return label.includes(q) || path.includes(q);
      });
      if (!first){
        toast("No match", "err", "Search");
        return;
      }
      const group = first.closest("details.group");
      if (group){
        group.open = true;
        closeOtherDetails(container, group);
      }
      first.scrollIntoView({behavior:"smooth", block:"center"});
      toast("Jumped to match", "ok", "Search");
    }
    $("fieldSearch").addEventListener("input", (e)=> filterExpertFields(e.target.value));
    $("fieldSearch").addEventListener("keydown", (e)=>{
      if (e.key === "Enter"){ e.preventDefault(); jumpToFirstMatch(); }
    });

    /* ---------- Navbar actions ---------- */
    $("barGenerate").onclick=()=>{
      refreshOutput();
      if (autoSaveRuns) { try { $("saveRunBtn").click(); } catch(_){} }
      $("cardOut").open = true;
      toast("Generated output", "ok", "Generate");
    };

    $("barCopy").onclick=async ()=>{
      try{
        const built = buildCanonicalDocForExport();
        const prompt = String(built.prompt || built.text || "").trim();
        const json = String(built.json || "").trim();
        const parts = [];
        if (prompt) parts.push("PROMPT" + prompt);
        if (json) parts.push("JSON" + json);
        const payload = parts.join("");
        if (!payload.trim()){ toast("Nothing to copy", "err", "Copy"); return; }
        const ok = await copyToClipboard(payload);
        ok ? toast("Copied prompt + JSON", "ok", "Copy") : toast("Copy failed", "err", "Clipboard");
      }catch(e){
        __PF_DIAG.add("barCopy", e);
        const txt = $("outMain")?.textContent || "";
        if (!txt.trim()){ toast("Nothing to copy", "err", "Copy"); return; }
        const ok = await copyToClipboard(txt);
        ok ? toast("Copied", "ok", "Copy") : toast("Copy failed", "err", "Clipboard");
      }
    };
// Output helpers
$("copyPackBtn").onclick = async ()=>{
  const pack = lastDerived?.promptPack || buildCanonicalDocForExport().compiled.promptPack;
  const ok = await copyToClipboard(pack);
  ok ? toast("Copied prompt pack", "ok", "Output") : toast("Copy failed", "err", "Clipboard");
};

$("copyJsonBtn").onclick = async ()=>{
  const { stripped } = buildCanonicalDocForExport();
  const txt = JSON.stringify(stripped, null, 2);
  const ok = await copyToClipboard(txt);
  ok ? toast("Copied JSON", "ok", "Output") : toast("Copy failed", "err", "Clipboard");
};

$("downloadPackBtn").onclick = ()=>{
  try{
    const pack = lastDerived?.promptPack || buildCanonicalDocForExport().compiled.promptPack;
    const blob = new Blob([pack], {type:"text/plain"});
    const a=document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `promptforge_ris_promptpack_${Date.now()}.txt`;
    document.body.appendChild(a); a.click(); a.remove();
    toast("Downloaded .txt", "ok", "Output");
  }catch(_){
    toast("Download failed", "err", "Output");
  }
};

$("saveRunBtn").onclick = ()=>{
  const { stripped, compiled } = buildCanonicalDocForExport();
  const rec = {
    id: uuidv4(),
    ts: new Date().toISOString(),
    name: (chatName || "").trim(),
    purpose: (purpose || "").trim(),
    template: currentTemplateName,
    run_id: compiled.manifest.run_id,
    doc_hash: compiled.manifest.doc_hash,
    prompt_pack_hash: compiled.manifest.prompt_pack_hash,
    prompt_pack: compiled.promptPack,
    doc: stripped
  };
  addRun(rec);
  toast("Saved run to history", "ok", rec.run_id);
};

$("exportRunsBtn").onclick = ()=>{
  const runs = loadRuns();
  const blob = new Blob([JSON.stringify(runs, null, 2)], {type:"application/json"});
  const a=document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = `promptforge_ris_runs_${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(a.href);
  toast("Exported runs", "ok", "Runs");
};

$("clearRunsBtn").onclick = ()=>{
  const ok = confirm("Clear all saved runs? This cannot be undone.");
  if (!ok) return;
  saveRuns([]);
  renderRunsDrawer();
  toast("Cleared runs", "ok", "Runs");
};



    /* ---------- Step 1 buttons ---------- */
    if ($("applyTemplateBtn")) $("applyTemplateBtn").onclick=()=>{
      const name = $("templateSelect").value;
      applyTemplate(name);
      toast("Applied template", "ok", name);
    };

    if ($("applyPresetBtn")) $("applyPresetBtn").onclick=()=>{
      applyPresetFromSelection();
      baseData = deepClone(currentData);
      renderStep2(); if ($("card3")) renderStep3(); if ($("card4")) renderStep4();
      refreshOutput();
      toast("Applied preset + generated output", "ok", ($("presetSelect").value||"").replace(/^.*:/,""));
      saveState();
    };

    $("outputMode").onchange=()=>{
      refreshOutput();
      toast("Output mode changed", "ok", $("outputMode").value);
      saveState();
    };

    /* ---------- Locks ---------- */
    $("unlockExpertBtn").onclick=()=>{
      expertUnlocked = true;
      if ($("card3")) renderStep3(); if ($("card4")) renderStep4();
      toast("Expert Mode unlocked", "ok", "Step 3");
      saveState();
    };

    $("unlockGodBtn").onclick=()=>{
      migrateToUltraElitePreservingSettings();
      expertUnlocked = true;
      godUnlocked = true;
      renderStep2(); if ($("card3")) renderStep3(); if ($("card4")) renderStep4();
      refreshOutput();
      toast("God Mode unlocked", "ok", "Step 4");
      saveState();
    };

    /* ---------- Step 0: detect template heuristic ---------- */
    function detectTemplateFromJson(parsed){
      try{
        const metaType = parsed?.meta?.template_type;
        if (metaType === "ultra_elite" || parsed?.system_profile || parsed?.environment || parsed?.rendering || parsed?.color_pipeline) return "Ultra Elite (ChatGPT5.2)";
        if (parsed?.identity?.identity_strength !== undefined && parsed?.prompt_profile && parsed?.composition && parsed?.subject) {
          // Heuristic: consistent_character vs others
          const strength = String(parsed?.identity?.identity_strength || "").toLowerCase();
          if (strength === "high" || (Array.isArray(parsed?.identity?.do_not_change) && parsed.identity.do_not_change.length)) return "Consistent Character";
          // full-body-ish
          const bv = String(parsed?.composition?.body_visibility || "").toLowerCase();
          if (bv.includes("full")) return "Single Image";
          return "ChatGPT Optimized";
        }
      }catch(_){}
      return null;
    }

    /* ---------- Step 0: Merge (order Name, Prompt, JSON) ---------- */
    function buildStep0MergedText(step0Name, step0Purpose, step0Prompt, jsonText){
  const name = (step0Name || "").trim();
  const purp = (step0Purpose || "").trim();
  const seed = (step0Prompt || "").trim();

  let parsed = null;
  if (jsonText && jsonText.trim()){
    const r = safeParseJson(jsonText);
    if (r.ok) parsed = r.value;
  }

  inferSchemaRegistry();

  const detected = (step0Detect && parsed) ? detectTemplateFromJson(parsed) : null;
  const tpl = (detected && TEMPLATE_BASES[detected]) ? detected : currentTemplateName;

  const base = deepClone(TEMPLATE_BASES[tpl]);
  base.meta = base.meta || {};
  base.meta.app_name = APP_NAME;
  base.meta.schema_version = APP_VERSION;
  base.meta.template = tpl;
  base.meta.chat_name = name;
  base.meta.purpose = purp;

  base.prompt_output = base.prompt_output || { user_prefix:"", negative_prompt:"", directive:"" };
  base.prompt_output.user_prefix = seed;

  if (parsed){
    const schemaPaths = SCHEMA_PATHS_BY_TEMPLATE[tpl] || ALL_SCHEMA_PATHS;
    quarantineUnknownFields(parsed, schemaPaths);
    coerceTypesInPlace(parsed);
    deepMerge(base, parsed);
  }

  applyMasterPrompt(base, includeMaster);
  const stripped = stripEmpties(base) || {};
  const compiled = compilePromptPack(stripped, { chatName: name, purpose: purp, templateName: tpl });
  stripped.meta = stripped.meta || {};
  stripped.meta.run_id = compiled.manifest.run_id;
  stripped.meta.doc_hash = compiled.manifest.doc_hash;
  stripped.meta.prompt_pack_hash = compiled.manifest.prompt_pack_hash;

  const outJson = JSON.stringify(stripped, null, 2);
  return `PROMPT_PACK:\n${compiled.promptPack}\n\nJSON:\n${outJson}`;
}

    function safeParseJson(text){
      if (!text || !text.trim()) return { ok:false, err:"Empty JSON" };
      try{
        const parsed = JSON.parse(text);
        if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) return { ok:false, err:"JSON must be an object" };
        return { ok:true, value: parsed };
      }catch(e){
        return { ok:false, err:"Invalid JSON" };
      }
    }

    function injectStep0IntoState(step0Name, step0Purpose, step0Prompt, parsedJson){
      // update chat name/purpose
      chatName = (step0Name || "").trim();
      purpose = (step0Purpose || "").trim();
      $("chatNameInput").value = chatName;
      $("purposeInput").value = purpose;

      // prompt seed goes to user_prefix (preserves assembler)
      const seed = (step0Prompt || "").trim();
      if (!currentData.prompt_output) currentData.prompt_output = { user_prefix:"", negative_prompt:"" };
      currentData.prompt_output.user_prefix = seed;

      // detect template + apply if enabled
      if (step0Detect && parsedJson){
        const detected = detectTemplateFromJson(parsedJson);
        if (detected && TEMPLATE_BASES[detected]){
          applyTemplate(detected);
          $("templateSelect").value = detected;
          toast(`Detected template: ${detected}`, "ok", "Step 0");
        }
      }

      // merge JSON into currentData (JSON overrides state where keys overlap)
if (parsedJson){
  inferSchemaRegistry();
  const schemaPaths = SCHEMA_PATHS_BY_TEMPLATE[currentTemplateName] || ALL_SCHEMA_PATHS;
  const quarantine = quarantineUnknownFields(parsedJson, schemaPaths);
  const coercions = coerceTypesInPlace(parsedJson);

  deepMerge(currentData, parsedJson);

  // standardize meta
  currentData.meta = currentData.meta || {};
  currentData.meta.app_name = APP_NAME;
  currentData.meta.schema_version = APP_VERSION;

  const qCount = Object.keys(quarantine||{}).length;
  if (qCount) toast(`Quarantined ${qCount} unknown field(s)`, "warn", "Step 0");
  if (coercions.length) toast(`Coerced ${coercions.length} field(s)`, "ok", "Step 0");
}

      renderStep2(); if ($("card3")) renderStep3(); if ($("card4")) renderStep4();
      refreshOutput();
      saveState();
    }

    if ($("mergeBtn")) $("mergeBtn").onclick=()=>{
      const typeSel = $("imageTypeSelect").value;
      const isCustom = typeSel === "Custom";
      const name = ($("step0Name").value || "").trim();
      const purp = ($("step0Purpose").value || "").trim();
      const prompt = ($("step0Prompt").value || "").trim();
      const jsonText = ($("step0Json").value || "").trim();

      // Step 0 also supports "Custom image type prompt" as an output helper: inject into prompt field if prompt empty
      if (isCustom){
        const customType = ($("customImageTypeName").value || "").trim();
        const customTpl = ($("customImageTypePrompt").value || "").trim();
        if (customType && !$("step0Purpose").value.trim()){
          $("step0Purpose").value = `Image type: ${customType}`;
        }
        if (customTpl && !prompt){
          $("step0Prompt").value = customTpl;
        }
      } else {
        // non-custom: if prompt empty, offer the analysis prompt as a starter (does not overwrite non-empty)
        if (!prompt && IMAGE_ANALYSIS_PROMPTS[typeSel]){
          $("step0Prompt").value = IMAGE_ANALYSIS_PROMPTS[typeSel];
        }
      }

      const mergedText = buildStep0MergedText(
        ($("step0Name").value || "").trim(),
        ($("step0Purpose").value || "").trim(),
        ($("step0Prompt").value || "").trim(),
        jsonText
      );
      $("mergedOut").textContent = mergedText;

      // Inject if enabled
      if (step0Inject){
        let parsed = null;
        if (jsonText){
          const r = safeParseJson(jsonText);
          if (!r.ok){
            toast(r.err, "err", "Step 0 JSON");
            return;
          }
          parsed = r.value;
        }
        injectStep0IntoState(
          ($("step0Name").value || "").trim(),
          ($("step0Purpose").value || "").trim(),
          ($("step0Prompt").value || "").trim(),
          parsed
        );
        toast("Merged + injected", "ok", "Step 0");
        return;
      }

      toast("Merged", "ok", "Step 0");
      saveState();
    };

    /* ---------- Save preset ---------- */
    function computeOverlayDiff(base, current){
      if (Array.isArray(current)){
        const bArr = Array.isArray(base) ? base : [];
        return (JSON.stringify(bArr) === JSON.stringify(current)) ? undefined : deepClone(current);
      }
      if (current && typeof current === "object"){
        const out = {};
        const keys = new Set([...Object.keys(base||{}), ...Object.keys(current||{})]);
        for (const k of keys){
          const d = computeOverlayDiff(base ? base[k] : undefined, current ? current[k] : undefined);
          if (d !== undefined) out[k]=d;
        }
        return Object.keys(out).length ? out : undefined;
      }
      return (base === current) ? undefined : current;
    }

    function savePresetAs(){
      const name = prompt("Preset name?");
      if (!name || !name.trim()){
        toast("Cancelled", "err", "Preset");
        return;
      }
      const overlay = computeOverlayDiff(baseData, currentData) || {};
      const presets = loadUserPresets();
      const existingIndex = presets.findIndex(p=>p.name===name.trim());
      const record = { name: name.trim(), overlay, saved_at: new Date().toISOString(), schema_version: APP_VERSION };

      if (existingIndex >= 0) presets[existingIndex] = record;
      else presets.push(record);

      saveUserPresets(presets);
      populatePresets();
      toast("Preset saved", "ok", record.name);
    }
    $("savePresetBtn").onclick=savePresetAs;
    if ($("presetSearch")) $("presetSearch").oninput=()=>renderPresetManager();

    /* ---------- Import/Export ---------- */

    /* ---------- Apply Changes (template/preset + output settings) ---------- */
    function applyChanges(){
      // Apply selected template first (if any), then preset overlay, then enforce requested output settings.
      const tName = ($("templateSelect") && $("templateSelect").value) ? $("templateSelect").value : currentTemplateName;
      if (tName && TEMPLATE_BASES[tName]){
        applyTemplate(tName);
      }

      // Apply preset selection (if any)
      if ($("presetSelect") && $("presetSelect").value){
        try{ applyPresetFromSelection(); }catch(e){ __PF_DIAG.add("applyPresetFromSelection", e); }
      }

      // Enforce output toggles: include master_prompt and choose output mode if present.
      if ($("masterSwitch")) setSwitch($("masterSwitch"), true);
      if ($("outputMode")){
        const want = "master_prompt_and_json";
        if ([...$("outputMode").options].some(o=>o.value===want)) $("outputMode").value = want;
      }

      baseData = deepClone(currentData);
      renderStep2();
      refreshOutput();
      saveState();
      toast("Applied changes", "ok", tName || "Template");
    }

    /* ---------- Import Template and/or Preset ---------- */
    function isPFIS(obj){
      return !!obj && typeof obj === "object" && !Array.isArray(obj) && typeof obj.pfis_version === "string" && !!obj.prompt;
    }
    function isRISDoc(obj){
      return !!obj && typeof obj === "object" && !Array.isArray(obj) && String(obj?.meta?.schema_id||"") === SCHEMA_ID_V1;
    }
    function mapPFISToRIS(pfis){
      // Best-effort conversion: compile PFIS blocks into RIS fields; preserve full PFIS in meta._import.
      const doc = deepClone(TEMPLATE_BASES["ChatGPT Optimized"]);
      ensureDefaultsForV1(doc);
      doc.meta = doc.meta || {};
      doc.meta.imported_from = "PFIS";
      doc.meta.imported_at = new Date().toISOString();
      doc.meta._import = pfis;

      // modeling
      if (pfis.modeling?.aspect_ratio) doc.output_specs.aspect_ratio = String(pfis.modeling.aspect_ratio);

      // subject entity → basic fields
      const ent = Array.isArray(pfis?.scene?.subject?.entities) ? pfis.scene.subject.entities[0] : null;
      if (ent){
        const a = ent.attributes || {};
        if (a.age) doc.subject.age = String(a.age);
        if (a.gender_presentation) doc.subject.gender = String(a.gender_presentation);
        if (a.ethnicity) doc.subject.ethnicity = String(a.ethnicity);
        if (a.hair) doc.subject.hair.details = String(a.hair);
        if (a.eyes) doc.subject.eyes.color = String(a.eyes);
        if (ent.expression) doc.subject.expression = String(ent.expression);
        if (ent.pose) doc.composition.framing = String(ent.pose);
      }

      // compile prompt blocks
      const blocks = Array.isArray(pfis?.prompt?.positive?.blocks) ? pfis.prompt.positive.blocks : [];
      const compiled = blocks
        .filter(b=>b && b.enabled!==false)
        .map(b=>{
          const toks = Array.isArray(b.tokens) ? b.tokens : [];
          const tt = toks.filter(t=>t && t.enabled!==false).map(t=>String(t.text||"").trim()).filter(Boolean);
          return tt.join(", ");
        })
        .filter(Boolean)
        .join(", ");

      if (compiled) doc.prompt_output.user_prefix = compiled;

      // negative
      const negItems = Array.isArray(pfis?.prompt?.negative?.items) ? pfis.prompt.negative.items : [];
      const neg = negItems.filter(n=>n && n.enabled!==false).map(n=>String(n.text||"").trim()).filter(Boolean);
      if (neg.length){
        doc.prompt_output.negative_prompt = neg.join(", ");
        doc.constraints.avoid = neg.slice();
        doc.constraints.negative = neg.slice();
      }
      return doc;
    }

    function importTemplateOrPresetFromPicker(){
      const fi = document.createElement("input");
      fi.type="file";
      fi.accept="application/json";
      fi.onchange=async ()=>{
        const f = fi.files && fi.files[0];
        if (!f) return;
        try{
          const txt = await f.text();
          const parsed = JSON.parse(txt);

          let mode = "preset";
          let doc = null;
          let templateName = null;

          // PFIS
          if (isPFIS(parsed)){
            mode = parsed?.template?.is_template ? "template" : "preset";
            doc = mapPFISToRIS(parsed);
          }else if (isRISDoc(parsed)){
            // If it already is an RIS doc, treat as preset unless flagged
            mode = parsed?.template?.is_template ? "template" : "preset";
            doc = parsed;
          }else{
            // External JSON requires explicit permission to convert
            const ok = confirm("This file is not a PromptForge (PFIS/RIS) document. Allow automatic conversion to an editable PromptForge format?");
            if (!ok){
              toast("Import aborted", "err", "No permission");
              return;
            }
            const mapped = mapExternalJsonToRIS(parsed);
            if (!mapped || !mapped.doc){
              toast("Import failed", "err", "Unsupported JSON");
              return;
            }
            mode = "preset";
            doc = mapped.doc;
            templateName = mapped.template || null;
          }

          // Apply/import based on mode
          if (mode === "template"){
            // Register as a new template (in-memory; persists via export bundle)
            const title = String(parsed?.meta?.title || parsed?.meta?.name || parsed?.title || "Imported Template").trim();
            const unique = Math.random().toString(16).slice(2,6).toUpperCase();
            const name = `Imported: ${title} (${unique})`;
            TEMPLATE_BASES[name] = deepClone(doc);
            TEMPLATE_INFO[name] = "Imported template";
            try{ ensureMetaForAllLeafPaths(TEMPLATE_BASES[name]); ensureDefaultsForV1(TEMPLATE_BASES[name]); }catch(_){}
            inferSchemaRegistry();
            populateTemplates();
            if ($("templateSelect")){
              $("templateSelect").value = name;
              currentTemplateName = name;
              applyTemplate(name);
              renderStep2(); refreshOutput(); saveState();
            }
            toast("Imported template", "ok", name);
            return;
          }

          // preset: save overlay to user preset store
          const baseName = templateName || currentTemplateName || ($("templateSelect") ? $("templateSelect").value : "ChatGPT Optimized");
          const base = deepClone(TEMPLATE_BASES[baseName] || TEMPLATE_BASES["ChatGPT Optimized"]);
          ensureDefaultsForV1(base);
          ensureDefaultsForV1(doc);
          const overlay = computeOverlayDiff(base, doc) || {};
          const presets = loadUserPresets();
          const pname = String(parsed?.meta?.title || parsed?.meta?.name || parsed?.title || f.name || "Imported Preset").replace(/\.json$/i,"").trim();
          const record = { name: pname, overlay, saved_at: new Date().toISOString(), schema_version: APP_VERSION };
          const i = presets.findIndex(p=>p.name===pname);
          if (i>=0) presets[i]=record; else presets.push(record);
          saveUserPresets(presets);
          renderPresetManager();
          populatePresets();
          toast("Imported preset", "ok", pname);
        }catch(e){
          console.error(e);
          __PF_DIAG.add("importTemplateOrPresetFromPicker", e);
          toast("Import failed", "err", "Invalid JSON");
        }
      };
      fi.click();
    }

    function exportJSONFile(){
  const { json } = buildCanonicalDocForExport();
  const blob = new Blob([json], {type:"application/json"});
  const a=document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = `promptforge_ris_${currentTemplateName.replace(/\s+/g,"_").toLowerCase()}_${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(a.href);
  toast("Exported JSON", "ok", "File");
}

    function importJSONFileFromPicker(){
  const fi = $("fileInput");
  fi.onchange = async ()=>{
    try{
      const file = fi.files && fi.files[0];
      if (!file) return;
      const txt = await file.text();
      const parsed = JSON.parse(txt);
      if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)){
        toast("Import JSON failed", "err", "JSON must be an object");
        return;
      }

      inferSchemaRegistry();

      // If this isn't a PromptForge-RIS doc, try best-effort mapping into our canonical editable doc.
      const schemaId = String(parsed?.meta?.schema_id || "");
      const isRIS = (schemaId === SCHEMA_ID_V1) || (!!parsed?.meta?.app_name && !!parsed?.prompt_profile);
      let working = parsed;
      if (!isRIS){
        const mapped = mapExternalJsonToRIS(parsed);
        if (mapped && mapped.doc){
          working = mapped.doc;
          // Hint template selection (non-binding; user can change after import)
          if (mapped.template && TEMPLATE_BASES[mapped.template]){
            currentTemplateName = mapped.template;
            $("templateSelect").value = mapped.template;
            $("templateDesc").textContent = TEMPLATE_INFO[mapped.template] || "";
            }
          toast("Imported external JSON", "ok", mapped.format || "External");
        }else{
          toast("Import JSON failed", "err", "Unsupported JSON format");
          return;
        }
      }

      // Template detection (best-effort). If not detected, keep current template.
      const detected = detectTemplateFromJson(working) || currentTemplateName;
      if (detected && TEMPLATE_BASES[detected]){
        currentTemplateName = detected;
        baseData = deepClone(TEMPLATE_BASES[detected]);
        $("templateSelect").value = detected;
        $("templateDesc").textContent = TEMPLATE_INFO[detected] || "";
        }

      // Quarantine unknown fields against detected template schema
      const schemaPaths = SCHEMA_PATHS_BY_TEMPLATE[currentTemplateName] || ALL_SCHEMA_PATHS;
      const quarantine = quarantineUnknownFields(working, schemaPaths);
      const coercions = coerceTypesInPlace(working);

      currentData = working;
      ensureDefaultsForV1(currentData);
      baseData = deepClone(currentData);
      try{ ensureDefaultsForV1(baseData); }catch(_){ }
      currentData.meta = currentData.meta || {};
      currentData.meta.app_name = APP_NAME;
      currentData.meta.schema_version = APP_VERSION;
      currentData.meta.schema_id = currentData.meta.schema_id || SCHEMA_ID_V1;

      // sync switch UI
      if ($("refSwitch")){
        const on = !!getByPath(currentData, "references.images_included");
        $("refSwitch").classList.toggle("on", on);
        $("refSwitch").setAttribute("aria-checked", on ? "true" : "false");
      }

      renderStep2(); if ($("card3")) renderStep3(); if ($("card4")) renderStep4();
      refreshOutput();
      toast("Imported JSON", "ok", currentTemplateName);

      const qCount = Object.keys(quarantine||{}).length;
      if (qCount) toast(`Quarantined ${qCount} unknown field(s)`, "warn", "Import");
      if (coercions.length) toast(`Coerced ${coercions.length} field(s)`, "ok", "Import");

      saveState();
    }catch(_){
      toast("Import JSON failed", "err", "Invalid JSON");
    }finally{
      fi.value = "";
    }
  };
  fi.click();
}

/* ---------- Canonical internal schema + external JSON import ---------- */

// Canonical internal schema target for cross-format imports.
// NOTE: This is a *model*, not a hard validator; we map into existing RIS doc shape
// so the current UI can edit it without new rendering components.
const PF_INTERNAL_V1 = {
  meta: {
    schema_id: SCHEMA_ID_V1,
    imported_from: "",
    imported_at: "",
    _import: {} // original source JSON (for audit/debug)
  }
  // The remaining structure is the PromptForge-RIS editable document shape.
};

function detectExternalFormat(obj){
  if (!obj || typeof obj !== "object" || Array.isArray(obj)) return null;
  if (obj.image_analysis && typeof obj.image_analysis === "object") return "IMAGE_ANALYSIS";
  if (obj.category && (obj.subject || obj.pose || obj.setting)) return "CATEGORY_SCHEMA";
  if (obj.meta && (obj.scene || obj.subject || obj.camera_perspective || obj.lighting)) return "META_SCENE_SCHEMA";
  // generic “prompt description” schema (subject/pose/setting/camera/lighting)
  const keys = Object.keys(obj);
  const hit = ["subject","pose","setting","camera","lighting"].some(k=> keys.includes(k));
  if (hit) return "GENERIC_PROMPT_SCHEMA";
  return null;
}

function asArray(x){
  if (Array.isArray(x)) return x.filter(v=>v!==null && v!==undefined).map(v=>String(v));
  if (typeof x === "string") return parseFreeformTokens(x);
  return [];
}

function joinClean(parts){
  return parts
    .filter(Boolean)
    .map(s=>String(s).trim())
    .filter(Boolean)
    .join("; ");
}

function mapExternalJsonToRIS(src){
  const fmt = detectExternalFormat(src);
  if (!fmt) return null;

  // Start from a stable base so the UI always has expected fields.
  const doc = deepClone(TEMPLATE_BASES["ChatGPT Optimized"]);
  ensureDefaultsForV1(doc);

  // Import metadata (non-rendered unless expert)
  doc.meta = doc.meta || {};
  doc.meta.imported_from = fmt;
  doc.meta.imported_at = new Date().toISOString();
  doc.meta._import = src; // audit trail

  // Shared extracts
  const neg = asArray(src.negative_prompt || src.negative || src.negatives);
  if (neg.length){
    doc.constraints.avoid = neg.slice();
    doc.constraints.negative = neg.slice();
    doc.prompt_output.negative_prompt = neg.join(", ");
  }

  // Aspect ratio + orientation
  const ar = String(src?.meta?.aspect_ratio || src?.technical_details?.aspect_ratio || src?.camera?.framing || "").trim();
  if (ar && /\d\s*[:/]\s*\d/.test(ar)){
    const norm = ar.replace("/",":").replace(/\s+/g,"");
    doc.output_specs.aspect_ratio = norm;
    const parts = norm.split(":");
    if (parts.length === 2 && Number(parts[0]) && Number(parts[1])){
      doc.composition.orientation = Number(parts[0]) < Number(parts[1]) ? "vertical" : "horizontal";
    }
  }

  // Format-specific mapping
  if (fmt === "CATEGORY_SCHEMA" || fmt === "GENERIC_PROMPT_SCHEMA"){
    // Subject
    if (src.subject){
      if (typeof src.subject.demographics === "string"){
        // best-effort parse
        if (/female/i.test(src.subject.demographics)) doc.subject.gender = "female";
        if (/male/i.test(src.subject.demographics)) doc.subject.gender = "male";
        const age = src.subject.demographics.match(/\b(\d{2})\b/);
        if (age) doc.subject.age = age[1];
        doc.subject.ethnicity = src.subject.demographics;
      }
      if (src.subject.hair){
        doc.subject.hair.color = src.subject.hair.color || doc.subject.hair.color;
        doc.subject.hair.style = src.subject.hair.style || doc.subject.hair.style;
        doc.subject.hair.details = joinClean([src.subject.hair.texture, src.subject.hair.movement, src.subject.hair.details]);
      }
      if (src.subject.face){
        doc.subject.face.shape = src.subject.face.shape || doc.subject.face.shape;
        doc.subject.face.features = joinClean([
          src.subject.face.eyes,
          src.subject.face.nose,
          src.subject.face.lips,
          src.subject.face.skin_details,
          src.subject.face.micro_details
        ]) || doc.subject.face.features;
        // eyes color hint
        if (typeof src.subject.face.eyes === "string"){
          const m = src.subject.face.eyes.match(/\b(blue|green|brown|hazel|grey|gray)\b/i);
          if (m) doc.subject.eyes.color = m[1].toLowerCase();
        }
      }
      if (src.subject.clothing){
        doc.clothing.top = src.subject.clothing.top || doc.clothing.top;
        doc.clothing.fit = src.subject.clothing.fit || doc.clothing.fit;
        doc.clothing.notes = joinClean([src.subject.clothing.texture, src.subject.clothing.details, src.subject.clothing.materials]);
      }
      if (src.subject.accessories?.jewelry){
        const items = asArray(src.subject.accessories.jewelry);
        if (items.length) doc.accessories.items = items;
      }
    }

    // Pose -> composition framing/mood
    if (src.pose){
      doc.composition.framing = joinClean([src.pose.orientation, src.pose.type, src.pose.posture, src.pose.limbs, src.pose.head_position]) || doc.composition.framing;
      doc.mood = joinClean([src.mood_and_expression?.tone, src.mood_and_expression?.expression, src.mood_and_expression?.atmosphere]) || doc.mood;
    }

    // Setting -> background
    if (src.setting){
      doc.background.location_type = src.setting.environment || doc.background.location_type;
      const bg = Array.isArray(src.setting.background_elements) ? src.setting.background_elements.join(", ") : src.setting.background_elements;
      doc.background.scene = joinClean([src.setting.environment, bg, src.setting.depth]) || doc.background.scene;
    }

    // Camera
    if (src.camera){
      doc.camera.photo_style = src.camera.shot_type || doc.camera.photo_style;
      doc.camera.focal_length = src.camera.focal_length || src.camera.focal_length_equivalent || doc.camera.focal_length;
      doc.camera.depth_of_field = src.camera.focus || src.camera.perspective || doc.camera.depth_of_field;
      doc.composition.shot_type = src.camera.shot_type || doc.composition.shot_type;
      doc.composition.camera_distance = src.camera.framing && /close/i.test(src.camera.framing) ? "close" : doc.composition.camera_distance;
    }

    // Lighting
    if (src.lighting){
      doc.lighting.type = src.lighting.source || src.lighting.type || doc.lighting.type;
      doc.lighting.direction = src.lighting.direction || doc.lighting.direction;
      doc.lighting.quality = src.lighting.quality || doc.lighting.quality;
      doc.lighting.notes = joinClean([src.lighting.highlights, src.lighting.shadows, src.lighting.effect]);
    }

    // Style
    if (src.style_and_realism){
      doc.style.genre = src.style_and_realism.style || doc.style.genre;
      doc.style.realism_strength = src.style_and_realism.fidelity || doc.style.realism_strength;
    }
    if (src.colors_and_tone){
      doc.style.color_grading = src.colors_and_tone.white_balance || doc.style.color_grading;
      doc.style.contrast = src.colors_and_tone.contrast || doc.style.contrast;
    }

    // Constraints
    if (src.constraints && typeof src.constraints === "object"){
      const hard = [];
      Object.keys(src.constraints).forEach(k=>{
        if (src.constraints[k] === true) hard.push(k.replace(/_/g," "));
      });
      if (hard.length){
        doc.constraints.must_include = [...new Set([...(doc.constraints.must_include||[]), ...hard])];
        doc.constraints.hard = doc.constraints.must_include.slice();
      }
    }
  }

  if (fmt === "META_SCENE_SCHEMA"){
    // meta + scene
    doc.prompt_profile.output_goal = src?.meta?.style || doc.prompt_profile.output_goal;
    doc.output_specs.aspect_ratio = src?.meta?.aspect_ratio || doc.output_specs.aspect_ratio;
    doc.camera.photo_style = src?.meta?.camera || doc.camera.photo_style;
    doc.camera.focal_length = src?.meta?.lens || doc.camera.focal_length;
    doc.camera.exposure = src?.meta?.iso || doc.camera.exposure;

    if (src.scene){
      doc.background.location_type = src.scene.location || doc.background.location_type;
      doc.background.scene = joinClean([
        src.scene.location,
        Array.isArray(src.scene.environment) ? src.scene.environment.join(", ") : src.scene.environment,
        src.scene.time,
        src.scene.atmosphere
      ]) || doc.background.scene;
      doc.mood = joinClean([src.scene.atmosphere]) || doc.mood;
    }

    if (src.camera_perspective){
      doc.composition.framing = joinClean([src.camera_perspective.pov, src.camera_perspective.angle, src.camera_perspective.framing]);
      doc.camera.depth_of_field = src.camera_perspective.focus || doc.camera.depth_of_field;
    }

    if (src.lighting){
      doc.lighting.type = src.lighting.type || doc.lighting.type;
      doc.lighting.notes = joinClean([src.lighting.key_light, src.lighting.fill_light, src.lighting.shadows, src.lighting.highlights]);
    }

    if (src.subject){
      const d = src.subject.demographics || {};
      doc.subject.gender = d.gender || doc.subject.gender;
      doc.subject.age = d.age || doc.subject.age;
      doc.subject.ethnicity = d.ethnicity || doc.subject.ethnicity;

      const f = src.subject.face || {};
      doc.subject.face.features = joinClean([f.structure, f.skin_texture, f.lips, f.eyes, f.brows]) || doc.subject.face.features;
      // eyes color hint
      if (typeof f.eyes === "string"){
        const m = f.eyes.match(/\b(blue|green|brown|hazel|grey|gray)\b/i);
        if (m) doc.subject.eyes.color = m[1].toLowerCase();
      }
      const h = src.subject.hair || {};
      doc.subject.hair.color = h.color || doc.subject.hair.color;
      doc.subject.hair.style = h.style || doc.subject.hair.style;
      doc.subject.hair.details = joinClean([h.texture]);
      doc.mood = joinClean([src.subject.expression, doc.mood]);
    }

    if (src.outfit){
      doc.clothing.top = src.outfit.top?.type || doc.clothing.top;
      doc.clothing.notes = joinClean([src.outfit.top?.details, src.outfit.top?.color, src.outfit.headwear?.item, src.outfit.headwear?.color]);
    }
  }

  if (fmt === "IMAGE_ANALYSIS"){
    // This source is “analysis”, so map into descriptive fields.
    const env = src.image_analysis.general_environment || {};
    const tech = src.image_analysis.technical_details || {};
    const light = src.image_analysis.lighting_conditions || {};
    doc.background.location_type = env.location_description || env.type || doc.background.location_type;
    doc.background.scene = joinClean([env.location_description, env.details, env.atmosphere]) || doc.background.scene;
    doc.composition.framing = joinClean([tech.camera_angle, tech.framing, tech.lens_effect]) || doc.composition.framing;
    doc.lighting.type = light.type || doc.lighting.type;
    doc.lighting.notes = joinClean([light.source, light.effect]);

    const person = Array.isArray(src.image_analysis.people) ? src.image_analysis.people[0] : null;
    if (person){
      doc.subject.gender = /woman|female/i.test(person.identity||"") ? "female" : doc.subject.gender;
      const hair = person.head_area?.hair || {};
      doc.subject.hair.color = hair.color || doc.subject.hair.color;
      doc.subject.hair.style = hair.style || doc.subject.hair.style;
      doc.subject.face.features = joinClean([
        person.head_area?.general_structure,
        person.head_area?.eye_area,
        person.head_area?.nose_area,
        person.head_area?.mouth_area
      ]) || doc.subject.face.features;
      doc.clothing.dress = person.clothing?.general_description || doc.clothing.dress;
      doc.clothing.notes = joinClean([
        person.clothing?.upper_part?.type,
        person.clothing?.upper_part?.color,
        person.clothing?.lower_part?.type,
        person.clothing?.lower_part?.color
      ]);
      doc.composition.shot_type = tech.framing || doc.composition.shot_type;
      doc.mood = joinClean([env.atmosphere]) || doc.mood;
    }
  }

  // Canonical v1 alias sync (keep both for compatibility)
  try { ensureDefaultsForV1(doc); } catch(_){ }

  // Template suggestion (heuristic)
  let template = null;
  const ratio = String(doc.output_specs?.aspect_ratio || "");
  if (ratio === "9:16") template = "Single Image";
  if (ratio === "4:5") template = "ChatGPT Optimized";

  return { doc, template, format: fmt };
}

/* ---------- Minimal self-tests (no external harness) ---------- */
window.PF_TESTS = window.PF_TESTS || {};
window.PF_TESTS.run = function(){
  const results = [];
  function assert(name, cond){
    if (!cond) throw new Error(`Test failed: ${name}`);
    results.push(name);
  }

  // Smoke: category schema
  const sample = {
    category: "BATHROOM_SELFIE_FLASH",
    subject: { demographics: "Adult woman, 21-27" },
    camera: { shot_type: "Selfie-style portrait", focal_length_equivalent: "24-28mm" },
    lighting: { source: "Phone flash" },
    negative_prompt: ["nudity","watermark"]
  };
  const mapped = mapExternalJsonToRIS(sample);
  assert("mapped exists", !!mapped && !!mapped.doc);
  assert("negative propagated", mapped.doc.prompt_output.negative_prompt.includes("nudity"));
  assert("camera focal length", String(mapped.doc.camera.focal_length).includes("24"));
  assert("gender inferred", mapped.doc.subject.gender === "female");

  return { ok: true, count: results.length, tests: results };
};

    function exportBundle(){
      // Bundle format: promptforge_ris_bundle@1
      // Includes: app state, current doc, baseline (baseData), user presets, and run history.
      const step0 = {
        imageType: $("imageTypeSelect")?.value || "Portrait Photography",
        customTypeName: $("customImageTypeName")?.value || "",
        customTypePrompt: $("customImageTypePrompt")?.value || "",
        name: $("step0Name")?.value || "",
        purpose: $("step0Purpose")?.value || "",
        prompt: $("step0Prompt")?.value || "",
        json: $("step0Json")?.value || "",
        merged: $("mergedOut")?.textContent || ""
      };

      // Ensure baseline + doc include v1 defaults for round-trip stability
      try { ensureDefaultsForV1(currentData); } catch(_){}
      try { ensureDefaultsForV1(baseData); } catch(_){}

      const bundle = {
        meta: {
          app_name: APP_NAME,
          schema_version: APP_VERSION,
          schema_id: SCHEMA_ID_V1,
          bundle_format: "promptforge_ris_bundle@1",
          exported_at: new Date().toISOString()
        },
        state: {
          template: currentTemplateName,
          preset_select: $("presetSelect")?.value || "builtin:— None —",

          include_master_prompt: includeMaster,
          output_mode: $("outputMode")?.value || "prompt_pack",

          expert_unlocked: expertUnlocked,
          god_unlocked: godUnlocked,

          save_as_json: saveAsJson,
          filename: $("filenameInput")?.value || "",

          chat_name: chatName,
          purpose: purpose,

          step0_inject: step0Inject,
          step0_detect: step0Detect,
          step0: step0,

          show_only_modified: showOnlyModified,
          auto_save_runs: autoSaveRuns,
          strict_validation: strictValidation,

          theme_mode: themeMode,
          lock_run_id: lockRunId,

          step_open: getStepOpenState()
        },
        current_data: currentData,
        base_data: baseData,
        user_presets: loadUserPresets(),
        runs: loadRuns()
      };

      const blob = new Blob([JSON.stringify(bundle,null,2)], {type:"application/json"});
      const a=document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = `promptforge_ris_bundle_${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(a.href);
      toast("Exported bundle", "ok", "Bundle");
    }

    function importBundleFromPicker(){
      const fi = $("fileInput");
      fi.onchange = async ()=>{
        try{
          const file = fi.files && fi.files[0];
          if (!file) return;
          const txt = await file.text();
          const bundle = JSON.parse(txt);

          // Basic sanity
          const fmt = bundle?.meta?.bundle_format || "";
          const sv = bundle?.meta?.schema_version || bundle?.meta?.app_version || "";
          if (!sv && !bundle?.current_data){
            toast("Import failed", "err", "Missing bundle data");
            return;
          }
          if (fmt && fmt !== "promptforge_ris_bundle@1"){
            toast("Import failed", "err", "Unsupported bundle_format");
            return;
          }

          // Replace local user presets + runs (round-trip accurate)
          if (Array.isArray(bundle.user_presets)) saveUserPresets(bundle.user_presets);
          if (Array.isArray(bundle.runs)){
            // cap defensively
            const capped = bundle.runs.slice(0, 30);
            saveRuns(capped);
            renderRunsDrawer();
          }

          // Template
          if (bundle.state?.template && TEMPLATE_BASES[bundle.state.template]) currentTemplateName = bundle.state.template;

          // Core flags
          includeMaster = !!bundle.state?.include_master_prompt;
          $("outputMode").value = bundle.state?.output_mode || "prompt_pack";
          expertUnlocked = !!bundle.state?.expert_unlocked;
          godUnlocked = !!bundle.state?.god_unlocked;

          // Save-as-JSON
          saveAsJson = !!bundle.state?.save_as_json;
          $("filenameInput").value = bundle.state?.filename || "";
          setSaveSwitch(saveAsJson);

          // Name/Purpose
          chatName = bundle.state?.chat_name || "";
          purpose = bundle.state?.purpose || "";
          $("chatNameInput").value = chatName;
          $("purposeInput").value = purpose;

          // Step 0 toggles
          step0Inject = bundle.state?.step0_inject !== undefined ? !!bundle.state.step0_inject : true;
          $("injectSwitch").classList.toggle("on", step0Inject);
          $("injectSwitch").setAttribute("aria-checked", step0Inject ? "true" : "false");

          step0Detect = bundle.state?.step0_detect !== undefined ? !!bundle.state.step0_detect : true;
          $("detectSwitch").classList.toggle("on", step0Detect);
          $("detectSwitch").setAttribute("aria-checked", step0Detect ? "true" : "false");

          // UI workflow toggles
          showOnlyModified = !!bundle.state?.show_only_modified;
          autoSaveRuns = !!bundle.state?.auto_save_runs;
          strictValidation = bundle.state?.strict_validation !== undefined ? !!bundle.state.strict_validation : true;

          themeMode = normalizeThemeMode(bundle.state?.theme_mode || bundle.state?.themeMode || localStorage.getItem(LS_THEME) || "auto");
          applyTheme(themeMode, {persist:true, quiet:true});
          lockRunId = !!bundle.state?.lock_run_id;

          if ($("diffSwitch")) {
            $("diffSwitch").classList.toggle("on", showOnlyModified);
            $("diffSwitch").setAttribute("aria-checked", showOnlyModified ? "true" : "false");
          }
          if ($("autoSaveSwitch")) {
            $("autoSaveSwitch").classList.toggle("on", autoSaveRuns);
            $("autoSaveSwitch").setAttribute("aria-checked", autoSaveRuns ? "true" : "false");
          }
          if ($("strictSwitch")) {
            $("strictSwitch").classList.toggle("on", strictValidation);
            $("strictSwitch").setAttribute("aria-checked", strictValidation ? "true" : "false");
          }
          if ($("runIdLockSwitch")) {
            $("runIdLockSwitch").classList.toggle("on", lockRunId);
            $("runIdLockSwitch").setAttribute("aria-checked", lockRunId ? "true" : "false");
          }


          // Restore doc + baseline (prefer bundle-provided baseline; else baseline = imported doc)
          if (bundle.current_data && typeof bundle.current_data === "object") currentData = bundle.current_data;
          ensureDefaultsForV1(currentData);
        if (lockRunId){
          const curRid = String(getByPath(currentData, "meta.run_id") || "").trim();
          setByPath(currentData, "meta.run_id", curRid || uuidv4());
        }

          if (bundle.base_data && typeof bundle.base_data === "object") baseData = bundle.base_data;
          else baseData = deepClone(currentData);
          ensureDefaultsForV1(baseData);

          // Rebuild template base if needed
          if (!TEMPLATE_BASES[currentTemplateName]) currentTemplateName = "ChatGPT Optimized";

          $("templateSelect").value = currentTemplateName;
          $("templateDesc").textContent = TEMPLATE_INFO[currentTemplateName] || "";
          setMasterSwitch(includeMaster);

          // Presets must be populated after restoring user presets
          populatePresets();
          const presetVal = bundle.state?.preset_select || "builtin:— None —";
          // Only set if it exists in options; else default.
          const hasOpt = [...$("presetSelect").options].some(o=>o.value===presetVal);
          $("presetSelect").value = hasOpt ? presetVal : "builtin:— None —";

          // Restore Step 0 fields
          const s0 = bundle.state?.step0;
          if (s0){
            $("imageTypeSelect").value = s0.imageType || "Portrait Photography";
            $("customImageTypeName").value = s0.customTypeName || "";
            $("customImageTypePrompt").value = s0.customTypePrompt || "";
            $("step0Name").value = s0.name || "";
            $("step0Purpose").value = s0.purpose || "";
            $("step0Prompt").value = s0.prompt || "";
            $("step0Json").value = s0.json || "";
            $("mergedOut").textContent = s0.merged || "";
            const isCustom = $("imageTypeSelect").value === "Custom";
            $("customTypeRow").style.display = isCustom ? "grid" : "none";
            $("customPromptRow").style.display = isCustom ? "grid" : "none";
          }

          // Sync references switch
          if ($("refSwitch")){
            const on = !!getByPath(currentData, "references.images_included");
            $("refSwitch").classList.toggle("on", on);
            $("refSwitch").setAttribute("aria-checked", on ? "true" : "false");
          }

          renderStep2(); if ($("card3")) renderStep3(); if ($("card4")) renderStep4();
          refreshOutput();

          if (bundle.state?.step_open) setStepOpenState(bundle.state.step_open);
          enforceSingleOpenStep();

          toast("Imported bundle", "ok", "Bundle");
          saveState();
        }catch(_){
          toast("Import bundle failed", "err", "Invalid JSON");
        }finally{
          fi.value = "";
        }
      };
      fi.click();
    }

    /* ---------- Resets ---------- */
    function resetToBase(){
      currentData = deepClone(TEMPLATE_BASES[currentTemplateName]);
      baseData = deepClone(currentData);
      renderStep2(); if ($("card3")) renderStep3(); if ($("card4")) renderStep4();
      refreshOutput();
      toast("Reset to template base", "ok", "Reset");
      saveState();
    }
    function resetEdits(){
      currentData = deepClone(baseData);
      renderStep2(); if ($("card3")) renderStep3(); if ($("card4")) renderStep4();
      refreshOutput();
      toast("Reset edits", "ok", "Reset");
      saveState();
    }
    function resetAllToDefaults(){
      currentTemplateName = "ChatGPT Optimized";
      currentData = deepClone(TEMPLATE_BASES[currentTemplateName]);
      baseData = deepClone(currentData);

      includeMaster = false;
      expertUnlocked = false;
      godUnlocked = false;
      showOnlyModified = false;
      autoSaveRuns = false;
      if ($("diffSwitch")) {
        $("diffSwitch").classList.remove("on");
        $("diffSwitch").setAttribute("aria-checked", "false");
      }
      if ($("autoSaveSwitch")) {
        $("autoSaveSwitch").classList.remove("on");
        $("autoSaveSwitch").setAttribute("aria-checked", "false");
      }

      $("outputMode").value = "prompt_pack";
      $("templateSelect").value = currentTemplateName;
      $("templateDesc").textContent = TEMPLATE_INFO[currentTemplateName] || "";
      setMasterSwitch(false);
      populatePresets();
      $("presetSelect").value = "builtin:— None —";

      // Save-as-JSON defaults
      $("filenameInput").value = "";
      setSaveSwitch(false);

      // Name/Purpose defaults
      chatName = "";
      purpose = "";
      $("chatNameInput").value = "";
      $("purposeInput").value = "";

      renderStep2(); if ($("card3")) renderStep3(); if ($("card4")) renderStep4();
      refreshOutput();

      setStepOpenState({ card0:false, card1:true, card2:false, card3:false, card4:false, cardOut:false });

      closeDrawer();
      toast("Reset ALL to Defaults", "ok", "Clean slate");
      saveState();
    }

    $("resetBaseBtn").onclick=()=>{ resetToBase(); closeDrawer(); };
    $("resetEditsBtn").onclick=()=>{ resetEdits(); closeDrawer(); };
    $("resetAllBtn").onclick=resetAllToDefaults;

    /* ---------- Chat name / purpose inputs ---------- */
    $("chatNameInput").addEventListener("input", ()=>{
      chatName = $("chatNameInput").value || "";
      saveState();
    });
    $("purposeInput").addEventListener("input", ()=>{
      purpose = $("purposeInput").value || "";
      saveState();
    });

    /* ---------- Persist/restore state ---------- */
    function saveState(){
      try{
        const s = {
          version: APP_VERSION,
          app_name: APP_NAME,
          template: currentTemplateName,
          includeMaster,
          outputMode: $("outputMode").value,
          presetSelect: $("presetSelect").value || "builtin:— None —",
          baseData,
          expertUnlocked,
          godUnlocked,
          showOnlyModified,
          autoSaveRuns,
          strictValidation,
          currentData,
          step_open: getStepOpenState(),
          saveAsJson,
          filename: $("filenameInput").value || "",
          chatName,
          purpose,
          step0Inject,
          step0Detect,
          step0: {
            imageType: $("imageTypeSelect").value || "Portrait Photography",
            customTypeName: $("customImageTypeName").value || "",
            customTypePrompt: $("customImageTypePrompt").value || "",
            name: $("step0Name").value || "",
            purpose: $("step0Purpose").value || "",
            prompt: $("step0Prompt").value || "",
            json: $("step0Json").value || "",
            merged: $("mergedOut").textContent || ""
          }
        };
        localStorage.setItem(LS_STATE, JSON.stringify(s));
        try{ localStorage.setItem(LS_THEME, themeMode); }catch(_){ }
      }catch(_){}
    }

    function restoreState(){
      try{
        let raw = localStorage.getItem(LS_STATE);
        if (!raw){
          // v1.0.x migration
          raw = localStorage.getItem("promptforge_ris_state_v100");
          if (!raw){
            // v0.8.x migration
            raw = localStorage.getItem("promptforge_ris_state_v080");
            if (!raw){
              // v0.7.x migration
              raw = localStorage.getItem("promptforge_ris_state_v070");
            }
          }
          if (raw) localStorage.setItem(LS_STATE, raw);
        }
        if (!raw) return false;
        const s = JSON.parse(raw);
        if (!s || !s.template || !TEMPLATE_BASES[s.template]) return false;

        currentTemplateName = s.template;
        includeMaster = !!s.includeMaster;
        expertUnlocked = !!s.expertUnlocked;
        godUnlocked = !!s.godUnlocked;
        showOnlyModified = !!s.showOnlyModified;
        autoSaveRuns = !!s.autoSaveRuns;

        themeMode = (s.themeMode || localStorage.getItem(LS_THEME) || "auto");
        lockRunId = !!s.lockRunId;

        applyTheme(themeMode, {persist:false, quiet:true});

        strictValidation = s.strictValidation !== undefined ? !!s.strictValidation : true;

        $("outputMode").value = s.outputMode || "prompt_pack";
        if ($("diffSwitch")) {
          $("diffSwitch").classList.toggle("on", showOnlyModified);
          $("diffSwitch").setAttribute("aria-checked", showOnlyModified ? "true" : "false");
        }
        if ($("autoSaveSwitch")) {
          $("autoSaveSwitch").classList.toggle("on", autoSaveRuns);
          $("autoSaveSwitch").setAttribute("aria-checked", autoSaveRuns ? "true" : "false");
        }

        if ($("strictSwitch")) {
          $("strictSwitch").classList.toggle("on", strictValidation);
          $("strictSwitch").setAttribute("aria-checked", strictValidation ? "true" : "false");
        }
        if ($("runIdLockSwitch")) {
          $("runIdLockSwitch").classList.toggle("on", lockRunId);
          $("runIdLockSwitch").setAttribute("aria-checked", lockRunId ? "true" : "false");
        }
        if (s.currentData && typeof s.currentData === "object") currentData = s.currentData;
        ensureDefaultsForV1(currentData);
        if (lockRunId){
          const curRid = String(getByPath(currentData, "meta.run_id") || "").trim();
          setByPath(currentData, "meta.run_id", curRid || uuidv4());
        }
        if ($("refSwitch")) {
          const ri = !!getByPath(currentData, "references.images_included");
          $("refSwitch").classList.toggle("on", ri);
          $("refSwitch").setAttribute("aria-checked", ri ? "true" : "false");
        }
        baseData = (s.baseData && typeof s.baseData === "object") ? s.baseData : deepClone(TEMPLATE_BASES[currentTemplateName]);
        try{ ensureDefaultsForV1(baseData); }catch(_){ }

        saveAsJson = !!s.saveAsJson;
        $("filenameInput").value = s.filename || "";
        setSaveSwitch(saveAsJson);

        chatName = s.chatName || "";
        purpose = s.purpose || "";
        $("chatNameInput").value = chatName;
        $("purposeInput").value = purpose;

        step0Inject = s.step0Inject !== undefined ? !!s.step0Inject : true;
        $("injectSwitch").classList.toggle("on", step0Inject);
        $("injectSwitch").setAttribute("aria-checked", step0Inject ? "true" : "false");

        step0Detect = s.step0Detect !== undefined ? !!s.step0Detect : true;
        $("detectSwitch").classList.toggle("on", step0Detect);
        $("detectSwitch").setAttribute("aria-checked", step0Detect ? "true" : "false");

        $("templateSelect").value = currentTemplateName;
        $("templateDesc").textContent = TEMPLATE_INFO[currentTemplateName] || "";
        setMasterSwitch(includeMaster);

        // Restore Step 0 fields
        if (s.step0){
          $("imageTypeSelect").value = s.step0.imageType || "Portrait Photography";
          $("customImageTypeName").value = s.step0.customTypeName || "";
          $("customImageTypePrompt").value = s.step0.customTypePrompt || "";
          $("step0Name").value = s.step0.name || "";
          $("step0Purpose").value = s.step0.purpose || "";
          $("step0Prompt").value = s.step0.prompt || "";
          $("step0Json").value = s.step0.json || "";
          $("mergedOut").textContent = s.step0.merged || "";
          // update custom visibility
          const isCustom = $("imageTypeSelect").value === "Custom";
          $("customTypeRow").style.display = isCustom ? "grid" : "none";
          $("customPromptRow").style.display = isCustom ? "grid" : "none";
        }

        populatePresets();
        if (s.presetSelect){
          const pv = String(s.presetSelect);
          const hasOpt = [...$("presetSelect").options].some(o=>o.value===pv);
          $("presetSelect").value = hasOpt ? pv : "builtin:— None —";
        }
        renderStep2(); if ($("card3")) renderStep3(); if ($("card4")) renderStep4();
        refreshOutput();

        if (s.step_open) setStepOpenState(s.step_open);
        enforceSingleOpenStep();

        return true;
      }catch(_){
        return false;
      }
    }

    /* ---------- Import/export: buttons ---------- */
    $("importBundleBtn").onclick=()=>{ closeDrawer(); importBundleFromPicker(); };
    $("exportBundleBtn").onclick=()=>{ closeDrawer(); exportBundle(); };
    $("importJSONBtn").onclick=()=>{ closeDrawer(); importJSONFileFromPicker(); };
    $("exportJSONBtn").onclick=()=>{ closeDrawer(); exportJSONFile(); };

    // Schema / macros / sweep
    if ($("copySchemaBtn")) $("copySchemaBtn").onclick=()=>{ closeDrawer(); copySchemaToClipboard(); };
    if ($("saveSchemaBtn")) $("saveSchemaBtn").onclick=()=>{ closeDrawer(); downloadSchemaFile(); };
    if ($("validateNowBtn")) $("validateNowBtn").onclick=()=>{ closeDrawer(); validateNow(); };

    if ($("macroHandsBtn")) $("macroHandsBtn").onclick=()=> macroHandsSafe();
    if ($("macroNoTextBtn")) $("macroNoTextBtn").onclick=()=> macroNoTextStrict();
    if ($("macroSkinBtn")) $("macroSkinBtn").onclick=()=> macroSkinRealism();
    if ($("macroIdentityBtn")) $("macroIdentityBtn").onclick=()=> macroIdentityLock();

    if ($("runSweepBtn")) $("runSweepBtn").onclick=()=> runSweep();
    if ($("clearSweepBtn")) $("clearSweepBtn").onclick=()=> clearSweep();

    /* ---------- Init ---------- */
    function init(){
      // Apply theme early (avoid flash)
      applyTheme(localStorage.getItem(LS_THEME) || themeMode || "auto", {persist:false, quiet:true});

      try{ renderChangelog(); }catch(e){ __PF_DIAG.add("renderChangelog", e); }
      Object.values(TEMPLATE_BASES).forEach(t => { ensureMetaForAllLeafPaths(t); ensureDefaultsForV1(t); });

      populateTemplates();
      populatePresets();

      if ($("schemaIdLabel")) $("schemaIdLabel").textContent = SCHEMA_ID_V1;
      renderSchemaPathList();
      renderSweepResults([]);

      $("templateSelect").value = currentTemplateName;
      $("presetSelect").value = "builtin:— None —";
      $("templateDesc").textContent = TEMPLATE_INFO[currentTemplateName] || "";

      // defaults
      $("outputMode").value = "prompt_pack";
      setMasterSwitch(false);
      setSaveSwitch(false);

      setupStepAccordion();

      inferSchemaRegistry();
      renderRunsDrawer();

      const restored = restoreState();
      if (!restored){
        renderStep2(); if ($("card3")) renderStep3(); if ($("card4")) renderStep4();
        refreshOutput();
        setStepOpenState({ card0:false, card1:true, card2:false, card3:false, card4:false, cardOut:false });
      }

      showChangelogIfNewVersion();
      toast(restored ? "Restored session" : "Initialized", "ok", APP_VERSION);
    }


function safeBoot(){
  try{
    init();
  }catch(err){
    __PF_DIAG.add("boot", err);
    try{
      ensureDiagPanel();
      renderDiagPanel();
      const p = document.getElementById("diagPanel");
      if (p) p.style.display = "block";
    }catch(_){}
  }
}


/* ---------- Self tests (opt-in) ---------- */
function __pfAssert(cond, msg){
  if (!cond) throw new Error(String(msg || "Assertion failed"));
}
function runSelfTests(){
  // Basic sanity: init should have populated key selectors and accordions should enforce single-open.
  __pfAssert($("templateSelect") && $("templateSelect").options.length > 0, "templateSelect not populated");
  __pfAssert($("presetSelect") && $("presetSelect").options.length > 0, "presetSelect not populated");
  __pfAssert($("changelogBody") && ($("changelogBody").textContent || "").trim().length > 0, "changelogBody empty");

  // Step accordion: opening one closes others (simulate toggle)
  const c1 = $("card1"), c2 = $("card2");
  if (c1 && c2){
    c1.open = true;
    c2.open = true;
    c2.dispatchEvent(new Event("toggle"));
    __pfAssert(c1.open === false, "step accordion did not close other steps");
  }
  return true;
}

    safeBoot();

    try{
      if (String(location.hash || "").includes("test")){
        runSelfTests();
        console.log("PromptForge self tests: PASS");
        toast("Self tests passed", "ok", "Tests");
      }
    }catch(e){
      console.error(e);
      __PF_DIAG.add("selfTests", e);
      try{ toast("Self tests failed", "err", "Tests"); }catch(_){ }
    }

  </script>
</body>
</html>
